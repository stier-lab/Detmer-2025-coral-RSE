---
title: "rse_new_scenario_analyses"
output: html_document
date: "2026-02-13"
---

README: updated version of the scenario analyses following January meeting with Fundemar, focusing on the orchard expansion and lab grow-out scenarios


```{r setup, include=FALSE}

# command + option + i for new code chunk
# command + shift + enter to run entire code chunk
# command + enter to run single line of code

# load packages
library(tidyverse) # command + shift + m for %>%
library(tictoc)

# load the model functions
source("coral_demographic_funs.R")
source("rse_funs.R")
```


# model set up

read in the parameter data and set default parameter values

```{r}
# read in the APAL data

# NOTE: Data files are stored in the separate Detmer-2025-coral-parameters repository.
# Update DATA_PATH to point to your local copy of that repository.
DATA_PATH <- "../Detmer-2025-coral-parameters"

# fragmentation data
apal_frag_summ <- read.csv(file.path(DATA_PATH, "standardized_data/apal_fragmentation_summ.csv"))
apal_frag <- read.csv(file.path(DATA_PATH, "standardized_data/apal_fragmentation.csv"))

# survival data
field_surv <- readRDS(file.path(DATA_PATH, "parameter_lists/field_surv_pars.rds"))
nurs_surv <- readRDS(file.path(DATA_PATH, "parameter_lists/nurs_surv_pars.rds"))
lab_surv <- readRDS(file.path(DATA_PATH, "parameter_lists/lab_surv_pars.rds"))


# growth data
field_growth <- readRDS(file.path(DATA_PATH, "parameter_lists/field_growth_pars.rds"))
nurs_growth <- readRDS(file.path(DATA_PATH, "parameter_lists/nurs_growth_pars.rds"))
lab_growth <- readRDS(file.path(DATA_PATH, "parameter_lists/lab_growth_pars.rds"))

# short-term lab survival data
apal_lab_short_surv <- read.csv(file.path(DATA_PATH, "standardized_data/apal_surv_lab_short.csv"))


```









# orchard expansion

What proportion of substrates should be outplanted to the orchard vs. reef?
-- How long does it take for initial investment in orchard to pay off for reef restoration outcomes? 
-- What is the cost of investing in the orchard to short-term restoration goals on the reef?


## set up defaults

```{r}

years <- 51 # number of years in simulation
n <- 5 # number of size classes

# define size class boundaries
SC1 <- 0
SC2 <- 10
SC3 <- 100
SC4 <- 900
SC5 <- 4000

A_mids <- c((SC1 + SC2)/2, (SC2 + SC3)/2, (SC3 + SC4)/2, (SC4 + SC5)/2, 9325) # midpoint areas of each size class (cm^2); last value is the 50% quantile of observations greater than SC5 in the standardized data from the literature

A_reef <- mean(c(4492.011, 10076.67, 8943.55)) # area of the reef (very rough estimates from kml file of Fundemar's sites)

# set upt the orchard, reef, and lab treatments
orchard_treatments <- c("orchard1") # orchards (could have multiple orchards and/or orchards with different post-outplanting treatments)
reef_treatments <- c("reef1") # reef treatments/subpopulations (e.g., could have "urchin outplanting" or "algal removal" or other postoutplanting treatments)
#lab_treatments <- c("0_T1", "1_T1") # lab treatments (cement = T1, ceramic = T2). "TX" is tile type, "X_" indicates whether recruits are outplanted immediately (0_) or the next year (0_1)
lab_treatments <- c("0_T1") # lab treatments "TX" is tile type (e.g., cement = T1, ceramic = T2), "X_" indicates whether recruits are outplanted immediately (0_) or the next year (1_)


# demographic parameters for each orchard and reef
field_surv1 <- field_surv
field_growth1 <- field_growth
nurs_surv1 <- nurs_surv
nurs_growth1 <- nurs_growth

# nursery data only available for size classes 1-2, so use the field data for the larger size classes
nurs_surv1$SC_surv_summ_df <- nurs_surv1$SC_surv_summ_df %>% filter(size_class < 3) %>% rbind(field_surv1$SC_surv_summ_df[field_surv1$SC_surv_summ_df$size_class > 2,])

nurs_growth1$summ_list[[3]] <- field_growth1$summ_list[[3]]
nurs_growth1$summ_list[[4]] <- field_growth1$summ_list[[4]]
nurs_growth1$summ_list[[5]] <- field_growth1$summ_list[[5]]

# calculate mean parameter values (survival, growth, shrinkage, fragmentation) for each 
all_pars <- default_pars_fun(n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), summ_metric_list = list(field_surv = "mean", field_growth = "mean", field_shrink = "mean", field_frag = "mean", nurs_surv = "mean", nurs_growth = "mean", nurs_shrink = "mean"), field_surv1, field_growth1, nurs_surv1, nurs_growth1, apal_frag_summ)

# reef parameters: survival
surv_pars.r <- all_pars$surv_pars.r

# reef parameters: growth
growth_pars.r <- all_pars$growth_pars.r

# reef parameters: shrinkage
shrink_pars.r <- all_pars$shrink_pars.r

# reef parameters: fragmentation
frag_pars.r <- all_pars$frag_pars.r

# density dependent survival (smallest size class only for now)
dens_pars.r <- list()
dens_pars.r[[1]] <- list() # first reef treatment/subpop
dens_pars.r[[1]][[1]] <- 0.02 # first source to first reef (external recruits)
dens_pars.r[[1]][[2]] <- dens_pars.r[[1]][[1]] # second source to first reef (first lab treatment)

# reef parameters: fecundity (for tracking reef reproductive output)
# estimates of number of eggs from spawning colonies in Fundemar's data (but don't know colony sizes): min = ~5200, 25% quantile = ~30000, 50% = ~93000, 75% = ~100000, max = ~140000, mean = ~72000

# update: use Fundemar's 2025 data (table 1 of their annual report) and assume no size-dependent reproduction because 1) lack of data and 2) Fundemar said they sometimes see smaller colonies spawning the most
# from Table 1: collected 1255111 embryos (100% fertilization) from 26 colonies (26 out of 31 of their monitored colonies spawned over a period of 2 days)

fec_pars.r <- list()
fec_pars.r[[1]] <- list()
fec_pars.r[[1]][[1]] <- c(0, 0, rep(1255111/26, 3)) #c(0, 0, 5000, 50000, 100000)
fec_pars.r[[1]][[2]] <- fec_pars.r[[1]][[1]]

# orchard parameters: survival
surv_pars.o <-all_pars$surv_pars.o #  list(list(c(0.8888889, 0.9314815, 0.95, 0.98, 1)))

# orchard parameters: growth
growth_pars.o <- all_pars$growth_pars.o

# orchard parameters: shrinkage
shrink_pars.o <- all_pars$shrink_pars.o

# orchard parameters: fragmentation
frag_pars.o <- all_pars$frag_pars.o

# density dependent survival (smallest size class only for now)
dens_pars.o <- list()
dens_pars.o[[1]] <- list() # first orchard
dens_pars.o[[1]][[1]] <- 0.02

# orchard parameters: fecundity
fec_pars.o <- list()
fec_pars.o[[1]] <- list() # first treatment
fec_pars.o[[1]][[1]] <- c(0, 0, rep(1255111/26, 3)) # first source

lambda <- 0 # external recruitment to reef

#lambda_R <- 10000 # mean number of larvae produced by reference reefs each year
lambda_R <- 1255111 # from Table 1 of Fundemar's report (total embryos collected in 2025)

# stochasticity parameters
sigma_s <- 0
sigma_f <- 0
ext_rand <- c(FALSE, FALSE) # whether 1) external recruitment and 2) reference reef reproduction is stochastic 
seeds <- c(1000, 5000, 10000, 40000)

# initial conditions in each reef subpopulation
N0.r <- list()
N0.r[[1]] <- list() # second reef subpop
N0.r[[1]][[1]] <- rep(0, n) # first source (external recruits)
N0.r[[1]][[2]] <- rep(0, n) # second source

# initial conditions in each orchard subpopulation
N0.o <- list()
N0.o[[1]] <- list() # first orchard treatment
N0.o[[1]][[1]] <- rep(0, n) # first source

N0.l <- list()
N0.l[[1]] <- 0
N0.l[[2]] <- 0


# disturbance parameters
dist_yrs <- c(years + 10) # years when disturbance occurs, can set to > years for none
#dist_yrs <- c(10)


# effects of disturbance on each reef subpop
dist_effects.r <- list()
dist_effects.r[[1]] <- list() # list where each element is the effects of disturbance on corals from each source in the 1st reef subpop (either "survival" for survival, "Tmat" for growth/survival, "Fmat" for fragmentation, or "fecundity" for reproduction)
dist_effects.r[[1]][[1]] <- list() # effects of disturbances on corals from first source in first reef subpop
dist_effects.r[[1]][[1]][[1]] <- c("survival") # effects of 1st disturbance on corals from first source in first reef subpop ([[1]][[1]][[2]] would be second disturbance, etc.)
dist_effects.r[[1]][[2]] <- list() # second source
dist_effects.r[[1]][[2]][[1]] <- c("survival")


# disturbance parameters for each reef subpop (what happens to the population parameters at each disturbance eve)
dist_pars.r <- list()

# first reef population
dist_pars.r[[1]] <- list() 
# first source to first reef subpop
dist_pars.r[[1]][[1]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.r[[1]][[1]], dist_surv0 = list(surv_pars.r[[1]][[1]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL) # list of disturbance parameters for the first source to the first reef population (defaults for each parameter type are NULL unless the disturbance affects them, as specified in dist_effects)
# second source to first reef subpop (lab tiles)
dist_pars.r[[1]][[2]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.r[[1]][[2]], dist_surv0 = list(surv_pars.r[[1]][[2]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL)


# disturbance effects for each orchard subpop
dist_effects.o <- list()

dist_effects.o[[1]] <- list() 
dist_effects.o[[1]][[1]] <- list() # effects of disturbances on corals from first source in first orchard treatment
dist_effects.o[[1]][[1]][[1]] <- c("survival") # effects of 1st disturbance on corals from first source in first reef subpop ([[1]][[1]][[2]] would be second disturbance, etc.)

# disturbance parameters for each orchard subpop
dist_pars.o <- list()

# first orchard treatment
dist_pars.o[[1]] <- list() 
# first source in first orchard treatment
dist_pars.o[[1]][[1]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.o[[1]][[1]], dist_surv0 = list(surv_pars.o[[1]][[1]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL) 

# lab parameters
# fractions of settled larvae in each lab treatment that survive to immediate outplanting each year
s0 <- matrix(NA, nrow = years, ncol = 2)
s0[,1] <- rep(0.95, years)
s0[,2] <- rep(0.95, years)

#s0[10,1] <- 0.05
#s0[10,2] <- 0.05

# fractions of settled larvae in each lab treatment that survive to 1 yr outplanting
s1 <- matrix(NA, nrow = years, ncol = 2)
s1[,1] <- rep(0.7, years)
s1[,2] <- rep(0.7, years)

m0 <- c(0.02, 0.02) # density dependent mortality rate of larvae in each lab treatment that get outplanted immediately
m1 <- c(0.02, 0.02) # density dependent mortality rate of larvae in each lab treatment that get outplanted after 1 year
#sett_props <- list(T1 = 0.15, T2 = 0.15) # proportion of larvae that settle on each tile type
sett_props <- list(T1 = 0.15) # proportion of larvae that settle on each tile type
size_props <- matrix(NA, nrow = length(lab_treatments), ncol = n) # matrix for fractions of retained recruits in each size class at the end of their year in the lab
size_props[1, ] <- c(1, 0, 0, 0, 0) # first lab treatment (0_T1)
#size_props[2, ] <- c(1, 0, 0, 0, 0) # second lab treatment (0_T2)
lab_pars <- list(s0 = s0, s1 = s1, m0 = m0, m1 = m1, sett_props = sett_props, size_props = size_props)

# restoration strategy parameters
tile_props <- list(T1 = 1) # proportion of tiles that are each type
orchard_yield <- 1 # percent of new orchard babies successfully collected
reef_yield <- 1 # percent of new reef babies successfully collected and fertilized
spawn_target <- 2000000 # target number of embryos to collect from orchard each year (note: if this is set to zero, there won't be any settlers)
reef_prop <- c(0.5) # proportion of lab recruits from each lab treatment outplanted to reef (1-proportion outplanted to orchard)
reef_out_props <- matrix(NA, nrow = length(lab_treatments), ncol = length(reef_treatments)) # proportion recruits going from each lab treatment to each reef treatment (row = origin lab treatment, column = destination reef treatment)
reef_out_props[1,] <- c(1) # from first lab treatment to each reef treatment (here there's just on intervention reef so they all go there)

orchard_out_props <- matrix(NA, nrow = length(lab_treatments), ncol = length(orchard_treatments)) # proportion recruits going from each lab treatment to each orchard treatment
orchard_out_props[1,] <- c(1) # from first lab treatment to each orchard 

# sizes allocated to each treatment
reef_areas <- c(A_reef)*10000 # m^2 given to each post-outplanting reef treatment/subpopulation, convert to cm^2 by multiplying by 10,000
lab_max <- 3100 # total number of tiles that the lab can accommodate 
lab_retain_max <- 0 # total number of tiles that the lab can keep for a year (must be less than or equal to lab_max; if > 0 then must have at least one "1_" lab treatment, if equal to lab max then must have all treatments be "1_")
tank_min <- 14600 # min number of embryos to put in a tank (reduce number of tanks used if less than this to avoid unrealistically small densities on the tiles)
tank_max <- 33333 # max number of embryos to put in a tank (impose a max because in reality if you had unlimited embryos you wouldn't put all of them in tanks because the density would be too high and presumably lead to high dens dep mortality). Chose max to correspond to number that would result in 50 embryos per tile, assuming 15% settlement and 100 tiles per tank

# 100*50/0.15

orchard_size <- c(30*500) # number of tiles each orchard has space for (500 stars x 30 tiles per star)


# coral transplanting
transplant <- rep(0, years) # years in which corals get transplanted from the orchard
#transplant[10] <- 1 # in 10th year, move corals from orchard to reef

null_mat <- matrix(0, nrow = years, ncol = n)
#rest_pars$trans_mats[[1]][[1]][which(transplant!=0)[1],] <- c(0, 0, 0, 2,0)# max number of colonies of each size class to move to reef in first transplant event
trans_mats <- list()
trans_mats[[1]] <- list() # first orchard 
trans_mats[[1]][[1]] <- null_mat # number of corals in each size class that originated from the first source of colonies for this orchard to transplant at each timepoint

# where on the reef to put the transplants
#rest_pars$trans_reef[[1]][[1]][which(transplant!=0)[1],] <- c(1, 1)# reef and source subpop to transport the corals to
trans_reef <- list()
trans_reef[[1]] <- list() # first orchard
trans_reef[[1]][[1]] <- matrix(c(1, 2), nrow = years, ncol = 2, byrow = T) # first source corals in this orchard get transplanted to the second source of corals in the first reef

rest_pars <- list(tile_props = tile_props, orchard_yield = orchard_yield, reef_yield = reef_yield, spawn_target = spawn_target, reef_prop = reef_prop, reef_out_props = reef_out_props, orchard_out_props = orchard_out_props, reef_areas = reef_areas, lab_max = lab_max, lab_retain_max = lab_retain_max, tank_min = tank_min, tank_max = tank_max, orchard_size = orchard_size, transplant = transplant, trans_mats = trans_mats, trans_reef = trans_reef)


sim1 <- rse_mod1(years, n, A_mids, surv_pars.r, dens_pars.r, growth_pars.r, shrink_pars.r, frag_pars.r, fec_pars.r, surv_pars.o, dens_pars.o, growth_pars.o, shrink_pars.o, frag_pars.o, fec_pars.o, lambda, lambda_R, sigma_s, sigma_f, ext_rand, seeds, dist_yrs, dist_pars.r, dist_effects.r, dist_pars.o, dist_effects.o, orchard_treatments, reef_treatments, lab_treatments, lab_pars, rest_pars, N0.r, N0.o, N0.l)

```



check numbers (note: getting the numbers to match perfectly for the reported embryos collected and recruits outplanted is a matter of picking the in-lab density dependent and independent mortality rates)

```{r}


#sim1$reef_out[[1]][[2]]

#(sim1$reef_out[[1]][[2]])/sim1$tiles_out_tot


#sim1$tiles_out_tot

reef1_tot <- model_summ(model_sim = sim1, location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

orch1_tot <- model_summ(model_sim = sim1, location = "orchard", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(max(reef1_tot), max(orch1_tot))), xlab = "year", ylab = "Area covered", lwd = 2)
lines(x = c(1:years), y = orch1_tot, type = "l", col = "dodgerblue", lwd = 2, lty = 2)
legend("topleft", legend = c("reef", "orchard"), col = c("black", "dodgerblue"), lwd = 2, lty = c(1, 2))


reef1_tot <- model_summ(model_sim = sim1, location = "reef", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

orch1_tot <- model_summ(model_sim = sim1, location = "orchard", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(max(reef1_tot), max(orch1_tot))), xlab = "year", ylab = "Population size", lwd = 2)
lines(x = c(1:years), y = orch1_tot, type = "l", col = "dodgerblue", lwd = 2, lty = 2)
legend("topleft", legend = c("reef", "orchard"), col = c("black", "dodgerblue"), lwd = 2, lty = c(1, 2))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(reef1_tot)), xlab = "year", ylab = "Area covered", lwd = 2)

plot(x = c(1:years), y = sim1$reef_out[[1]][[2]], type = "l", ylim = c(0, max(max(sim1$reef_out[[1]][[2]], na.rm = T), max(sim1$orchard_out[[1]][[1]], na.rm = T))))
lines(x = c(1:years), y = sim1$orchard_out[[1]][[1]], col = "dodgerblue")

sim1$reef_out


sim1$reef_babies_used
sim1$orchard_babies_used

sim1$reef_tiles_out + sim1$orchard_tiles_out

```




reef_out and orchard_out are inversely related because tiles that don't go to the orchard go to the reef

Old problem (fixed now):
why does the orchard population decline over time? 1) density dependent mortality (as the orchard grows, there are more larvae produced, so the densities on the settlement tiles get super high) and 2) orchard gets full in terms of tiles so no new tiles are outplanted, but there are still tiles with multiple corals per tile, so the number of corals decreases but no new tiles are outplanted still (the reef stars are still full)

Fixes: 1) put a max number of larvae per tile in the lab (so you don't get crazy high densities that cause them all to die)...OR just make an upstream max total number of embryos that can be handled in the lab and 2) need to figure out density dependence in the orchard and number of corals per tile... because eventually there's only room for one per tile

```{r}

# plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][1,], type = "l")
# plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][2,], type = "l")
# plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][3,], type = "l")
# plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][4,], type = "l")
# plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][5,], type = "l")
# 
# sim1$orchard_out[[1]][[1]]

# It looks like the problem is maybe just that some of the orchard corals are dying but there are still at least one per tile so nothing new is being outplanted but the total number in the orchard is decreasing

```

## parameter sets

NOTE: this is where you can decide whether to include only local data from the Demographic Republic or regional data from the Caribbean

```{r}
# get the random parameter sets

# number of iterations
n_sample1 <- 100

# full parameter sets
field_surv1 <- field_surv
field_growth1 <- field_growth
nurs_surv1 <- nurs_surv
nurs_growth1 <- nurs_growth

# nursery data only available for size classes 1-2, so use the field data for larger size classes
nurs_surv1$SC_surv_df <- nurs_surv1$SC_surv_df %>% filter(size_class < 3) %>% rbind(field_surv1$SC_surv_df[field_surv1$SC_surv_df$size_class > 2,])

nurs_growth1$mat_list[[3]] <- field_growth1$mat_list[[3]]
nurs_growth1$mat_list[[4]] <- field_growth1$mat_list[[4]]
nurs_growth1$mat_list[[5]] <- field_growth1$mat_list[[5]]


set.seed(500)
all_pars_R <- rand_pars_fun(n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), n_sample = n_sample1, field_surv = field_surv1, field_growth = field_growth1, nurs_surv = nurs_surv1, nurs_growth = nurs_growth1, apal_frag)

```


## no disturbance

```{r}

# run for 100 years because interested in both short-term (5 years) and long-term (100 years) but it's more efficient to just run everything once for 100 years

L1 <- 50
prop_set <- seq(from = 0, to = 1, length.out = L1) # proportion tiles outplanted to reef (can be higher than this if orchard gets full though)

orch_exp_list <- list()


# outer loop = demographic parameter values
# inner loop = proportion to outplant to the reef

tic()

for(i in 1:n_sample1){ # for each parameter set
  
  # set up the parameters
  
  surv_pars.r <- all_pars_R$surv_pars_L.r[[i]] 
  growth_pars.r <- all_pars_R$growth_pars_L.r[[i]]
  shrink_pars.r <- all_pars_R$shrink_pars_L.r[[i]] 
  frag_pars.r <- all_pars_R$frag_pars_L.r[[i]]
  surv_pars.o <- all_pars_R$surv_pars_L.o[[i]] 
  growth_pars.o <- all_pars_R$growth_pars_L.o[[i]]
  shrink_pars.o <- all_pars_R$shrink_pars_L.o[[i]]
  frag_pars.o <- all_pars_R$frag_pars_L.o[[i]]
  
  # holding list for model simulations with this parameter set
  mod_list <- list()
  
  for(j in 1:length(prop_set)){ # for each proportion outplanted to reef
    
    rest_pars_ij <- rest_pars
    
    rest_pars_ij$reef_prop <- prop_set[j] # proportion of tiles outplanted to reef
    
    # run the model
    sim_ij <- rse_mod1(years, n, A_mids, surv_pars.r, dens_pars.r, growth_pars.r, shrink_pars.r, frag_pars.r, fec_pars.r, surv_pars.o, dens_pars.o, growth_pars.o, shrink_pars.o, frag_pars.o, fec_pars.o, lambda, lambda_R, sigma_s, sigma_f, ext_rand, seeds, dist_yrs, dist_pars.r, dist_effects.r, dist_pars.o, dist_effects.o, orchard_treatments, reef_treatments, lab_treatments, lab_pars, rest_pars_ij, N0.r, N0.o, N0.l)
    
    
    # save the output
    mod_list[[j]] <- sim_ij
    
  } # end of iterations over outplanting proportions
  
  
  orch_exp_list[[i]] <- mod_list
  
} # end of iterations over parameter sets

toc()

# record each performance metrics at each time point (can later look at which proportion resulted in the max value of each metric at each time point)




```

process results


```{r}
# # function for extracting performance metrics from the orchard expansion simulations
# orch_exp_metric_fun <- function(sim_list, n_sample1, L1, max_yr){
#   
#   
#   # calculate the performance metrics for each parameter combination
#   for(i in 1:n_sample1){ # for each parameter combination
#     
#     # make the holding data frame
#     dt_i <- data.frame(
#   par_rep = rep(i, L1), # random parameter replicate
#   prop_out = rep(NA, L1), # proportion outplanted to reef
#   reef_cover_mean = rep(NA, L1), # m2 of coral cover on reef (mean over years 1-max_yr)
#   reef_cover_sd = rep(NA, L1), # variability in coral cover on reef (sd over years 1-max_yr)
#   reef_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals on reef
#   reef_function_sd = rep(NA, L1), # variability in number of large corals on reef
#   reef_tiles_out_tot = rep(NA, L1), # total number of tiles outplanted to reef
#   reef_area_out_tot = rep(NA, L1), # total area of reef over which tiles were outplanted 
#   reef_recruits_out_tot = rep(NA, L1), # total recruits outplanted to reef
#   reef_ROI_mean = rep(NA, L1), # corals on reef per dollar spent, averaged over max_yr years
#  # tot_dollar_costs = rep(NA, L1), # total amount of money spent on restoration over max_yr years 
#  tot_costs <- rep(NA, L1), # total amount spent over length of simulation
#   reef_cover_cost = rep(NA, L1), # avg coral cover on reef over max_yr years compared to if all corals were put on the reef
#   orch_rep_cost = rep(NA, L1), # avg orchard reproduction over max_yr years compared to if all corals were put in the orchard
#   orch_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals in orchard
#   orch_function_sd = rep(NA, L1) # variability in number of large corals in orchard
# )
#     
#     # NOTE: could make coral cover per m2 where m2 is the total area outplanted up to that time point, but then you might get numbers that look high if very few tiles were outplanted so that might be too confusing...
#     
#     # get max reef and orchard values for calculating costs
#     orch_rep_0 <- model_summ(model_sim = sim_list[[i]][[1]], location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
#     
#     orch_rep_max <- mean(orch_rep_0[2:max_yr], na.rm = T)
#     
#     reef_cover_1 <- model_summ(model_sim = sim_list[[i]][[L1]], location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
#     
#     reef_cover_max <- mean(reef_cover_1[2:max_yr], na.rm = T)
#     
#     for(j in 1:L1){ # for each proportion outplanted to reef
#       
#       sim_ij <- sim_list[[i]][[j]]
#       
#       # reef cover
#       reef_cover_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
#       
#       # reef function
#       reef_fun_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))
# 
#       # orchard rep
# orch_rep_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
# 
#       # orchard function
# orch_fun_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))
# 
#       dt_i$prop_out[j] <- prop_set[j]
#       dt_i$reef_cover_mean[j] <- mean(reef_cover_ij[2:max_yr], na.rm = T)
#       dt_i$reef_cover_sd[j] <- sd(reef_cover_ij[2:max_yr], na.rm = T)
#       dt_i$reef_function_mean[j] <- mean(reef_fun_ij[2:max_yr], na.rm = T)
#       dt_i$reef_function_sd[j] <- sd(reef_fun_ij[2:max_yr], na.rm = T)
#       dt_i$reef_tiles_out_tot[j] <- sum(sim_ij$reef_tiles_out[2:max_yr], na.rm = T)
#       dt_i$reef_area_out_tot[j] <- dt_i$reef_tiles_out_tot[j]*5
#       dt_i$reef_recruits_out_tot[j] <- sum(sim_ij$reef_out[[1]][[2]][2:max_yr], na.rm = T)
#       dt_i$reef_cover_cost[j] <- dt_i$reef_cover_mean[j]/reef_cover_max
#       dt_i$orch_rep_cost[j] <- mean(orch_rep_ij[2:max_yr], na.rm = T)/orch_rep_max
#       dt_i$orch_function_mean[j] <- mean(orch_fun_ij[2:max_yr], na.rm = T)
#       dt_i$orch_function_sd[j] <- sd(orch_fun_ij[2:max_yr], na.rm = T)
#       
#       # costs: baseline cost per reef star ($84.6), yearly costs of tiles ($1 per cement and $7 per ceramic; use same ratio as in 2025 which was 50-50), cost of orchard maintenance is currently $530 per day and they have ~80 reef stars, so assume this scales linearly with number of substrates in the orchard and that with the reef stars they need to do this maintenance twice a year. But that $530 includes the boat, and later say transportation is 300 per day with their boat for maintenance and reef star seeding... so only make $230 scale with number of substrates in orchard, and have the 300 (boat) be the twice per year maintenance costs
#       # QUESTION: how will maintenance costs scale with number of substrates in the orchard?
#       # outplanting costs (estimated from transportation and diving costs): 300 per day for boat + 200 per day for 4 divers. For now assume it just takes one day for each (so double if you are outplanting to both the reef and orchard)
#       # QUESTION: how many substrates can be outplanted to orchard and intervention reef per day
#       # lab costs: $443/d for first week, then $200/d for following weeks, so a total of 432*7 + 200*(7*3) per month. But here assuming they are outplanted quickly so just use the 443*7 + 200*7 = 4501
#       # boat maintenance: 1200 every 3 months = 4800 per year
#       # logistics: 500 per month = 6000 per year
#       # diver costs: gave costs per dive but not sure about how many dives per year. Ignore non-outplanting/spawning collection/maintenance dives for now
#       # larval collection costs: 6,500 per spawning event on reference reefs, 400 per year for permits. Assume you don't need permits 
#       # QUESTION: how do think the costs of larval collection in the orchard will compare to collection from the reference reefs? (e.g., won't need permits?)
#       
#       # baseline costs
#     # outplanting costs
#     if(prop_set[j] > 0 & prop_set[j] < 1){ # if there is outplanting to both orch and reef
#         out_costs <- 2*(300 + 200)
#         
#       } else{
#         
#         out_costs <- 1*(300 + 200)
#       }
#     
#     base_costs <- (rest_pars$lab_max*(0.5*1 + 0.5*7) + 4501 + out_costs + 4800 + 6000)*length(2:max_yr)
#     
#     # add the initial costs (costs of reef stars) to year 1
#     base_costs[1] <- 84.6*rest_pars$orchard_size/30
#       
#       spawn_costs <- rep(NA, length(2:max_yr)) # collecting costs
#       maint_costs <- rep(NA, length(2:max_yr)) # costs of orchard maintenance
#       
#       for(ii in 2:max_yr){
#         spawn_costs[ii-1] <- ifelse(sim_ij$reef_babies_used[ii-1] > 0, 6500 + 400, 0) + ifelse(sim_ij$orchard_babies_used[ii-1] > 0, 6500, 0)
#         
#         # get number of tiles in orchard(s)
#         orch_tiles <- rep(NA, length(orchard_treatments))
#         
#         for(ss in 1:length(orchard_treatments)){
#           orch_tiles[ss] <- sim_ij$orchard_tiles[[ss]][ii-1]
#         }
#         
#         orch_tiles <- sum(orch_tiles)
#         
#         maint_costs[ii-1] <- (230/80*orch_tiles + ifelse(orch_tiles > 0, 300,0))*2# assume maintenance twice per year, and the 230/80 is the approximate cost of the maintenance (diving, labor) per substrate, 300 is the boat costs (doesn't scale with number of substrates, but is zero if there are no tiles in the orchard)
#         
#       }
#       
#      # spawn_costs <- sum(spawn_costs)
#      # maint_costs <- sum(maint_costs)
#       
#      tot_costs <- base_costs + spawn_costs + maint_costs
#      
#      dt_i$tot_costs[j] <- sum(tot_costs)
#       
#       #dt_i$tot_dollar_costs[j]
#       dt_i$reef_ROI_mean[j] <- mean(reef_cover_ij[2:max_yr]/tot_costs)
#     }
#     
#   if(i == 1){
#     dt <- dt_i
#   } else{
#     dt <- rbind(dt, dt_i)
#   }
#     
#   }
#   
#   return(dt) # return the data frame
#   
# }
# 
# 
# # data frame for all the performance metrics at year 5 (use data from time points 2 through 6)
# # D0 for no disturbance simulations
# orch_exp_5_D0 <- orch_exp_metric_fun(sim_list = orch_exp_list, n_sample1, L1, max_yr = 6)
# 
# View(orch_exp_5_D0)
# # make this a function of the list, n_sample1, L1, and the time point of interest
# 
# # data frame for all the performance metrics at year 50 (use data from time points 2 through 51)
# orch_exp_50_D0 <- orch_exp_metric_fun(sim_list = orch_exp_list, n_sample1, L1, max_yr = 51)


```


update: focus on 5 metrics

```{r}
# 1) coral cover on reef, 2) orchard function (loosely defined to include ecological function and reproduction since these are highly correlated in the model, calculate as sum or area covered of all reproductively mature size classes in the orchard), 3) reef ROI (m2 coral on reef per dollar spent), 4) total ROI (m2 coral on reef and orchard per dollar spent), 5) total costs, and 6) number of recruits outplanted to reef?

# function for extracting performance metrics from the orchard expansion simulations
orch_exp_metric_fun <- function(sim_list, n_sample1, L1, max_yr){
  
  
  # calculate the performance metrics for each parameter combination
  for(i in 1:n_sample1){ # for each parameter combination
    
    # make the holding data frame
    dt_i <- data.frame(
  par_rep = rep(i, L1), # random parameter replicate
  prop_out = rep(NA, L1), # proportion outplanted to reef
  reef_cover_mean = rep(NA, L1), # m2 of coral cover on reef (mean over years 1-max_yr)
  reef_cover_sd = rep(NA, L1), # variability in coral cover on reef (sd over years 1-max_yr)
  reef_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals on reef
  reef_function_sd = rep(NA, L1), # variability in number of large corals on reef
  reef_tiles_out_tot = rep(NA, L1), # total number of tiles outplanted to reef
  reef_area_out_tot = rep(NA, L1), # total area of reef over which tiles were outplanted 
  reef_recruits_out_tot = rep(NA, L1), # total recruits outplanted to reef
  reef_ROI_mean = rep(NA, L1), # corals on reef per dollar spent, averaged over max_yr years
 # tot_dollar_costs = rep(NA, L1), # total amount of money spent on restoration over max_yr years 
 tot_costs <- rep(NA, L1), # total amount spent over length of simulation
  reef_cover_cost = rep(NA, L1), # avg coral cover on reef over max_yr years compared to if all corals were put on the reef
  orch_rep_cost = rep(NA, L1), # avg orchard reproduction over max_yr years compared to if all corals were put in the orchard
  orch_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals in orchard
  orch_function_sd = rep(NA, L1) # variability in number of large corals in orchard
)
    
    # NOTE: could make coral cover per m2 where m2 is the total area outplanted up to that time point, but then you might get numbers that look high if very few tiles were outplanted so that might be too confusing...
    
    # get max reef and orchard values for calculating costs
    orch_rep_0 <- model_summ(model_sim = sim_list[[i]][[1]], location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
    
    orch_rep_max <- mean(orch_rep_0[2:max_yr], na.rm = T)
    
    reef_cover_1 <- model_summ(model_sim = sim_list[[i]][[L1]], location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
    
    reef_cover_max <- mean(reef_cover_1[2:max_yr], na.rm = T)
    
    for(j in 1:L1){ # for each proportion outplanted to reef
      
      sim_ij <- sim_list[[i]][[j]]
      
      # reef cover
      reef_cover_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
      
      # reef function
      reef_fun_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))

      # orchard rep
orch_rep_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

      # orchard function
orch_fun_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))

      dt_i$prop_out[j] <- prop_set[j]
      dt_i$reef_cover_mean[j] <- mean(reef_cover_ij[2:max_yr], na.rm = T)
      dt_i$reef_cover_sd[j] <- sd(reef_cover_ij[2:max_yr], na.rm = T)
      dt_i$reef_function_mean[j] <- mean(reef_fun_ij[2:max_yr], na.rm = T)
      dt_i$reef_function_sd[j] <- sd(reef_fun_ij[2:max_yr], na.rm = T)
      dt_i$reef_tiles_out_tot[j] <- sum(sim_ij$reef_tiles_out[2:max_yr], na.rm = T)
      dt_i$reef_area_out_tot[j] <- dt_i$reef_tiles_out_tot[j]*5
      dt_i$reef_recruits_out_tot[j] <- sum(sim_ij$reef_out[[1]][[2]][2:max_yr], na.rm = T)
      dt_i$reef_cover_cost[j] <- dt_i$reef_cover_mean[j]/reef_cover_max
      dt_i$orch_rep_cost[j] <- mean(orch_rep_ij[2:max_yr], na.rm = T)/orch_rep_max
      dt_i$orch_function_mean[j] <- mean(orch_fun_ij[2:max_yr], na.rm = T)
      dt_i$orch_function_sd[j] <- sd(orch_fun_ij[2:max_yr], na.rm = T)
      
      # costs: baseline cost per reef star ($84.6), yearly costs of tiles ($1 per cement and $7 per ceramic; use same ratio as in 2025 which was 50-50), cost of orchard maintenance is currently $530 per day and they have ~80 reef stars, so assume this scales linearly with number of substrates in the orchard and that with the reef stars they need to do this maintenance twice a year. But that $530 includes the boat, and later say transportation is 300 per day with their boat for maintenance and reef star seeding... so only make $230 scale with number of substrates in orchard, and have the 300 (boat) be the twice per year maintenance costs
      # QUESTION: how will maintenance costs scale with number of substrates in the orchard?
      # outplanting costs (estimated from transportation and diving costs): 300 per day for boat + 200 per day for 4 divers. For now assume it just takes one day for each (so double if you are outplanting to both the reef and orchard)
      # QUESTION: how many substrates can be outplanted to orchard and intervention reef per day
      # lab costs: $443/d for first week, then $200/d for following weeks, so a total of 432*7 + 200*(7*3) per month. But here assuming they are outplanted quickly so just use the 443*7 + 200*7 = 4501
      # boat maintenance: 1200 every 3 months = 4800 per year
      # logistics: 500 per month = 6000 per year
      # diver costs: gave costs per dive but not sure about how many dives per year. Ignore non-outplanting/spawning collection/maintenance dives for now
      # larval collection costs: 6,500 per spawning event on reference reefs, 400 per year for permits. Assume you don't need permits 
      # QUESTION: how do think the costs of larval collection in the orchard will compare to collection from the reference reefs? (e.g., won't need permits?)
      
      # baseline costs
    # outplanting costs
    if(prop_set[j] > 0 & prop_set[j] < 1){ # if there is outplanting to both orch and reef
        out_costs <- 2*(300 + 200)
        
      } else{
        
        out_costs <- 1*(300 + 200)
      }
    
    base_costs <- (rest_pars$lab_max*(0.5*1 + 0.5*7) + 4501 + out_costs + 4800 + 6000)*length(2:max_yr)
    
    # add the initial costs (costs of reef stars) to year 1
    base_costs[1] <- 84.6*rest_pars$orchard_size/30
      
      spawn_costs <- rep(NA, length(2:max_yr)) # collecting costs
      maint_costs <- rep(NA, length(2:max_yr)) # costs of orchard maintenance
      
      for(ii in 2:max_yr){
        spawn_costs[ii-1] <- ifelse(sim_ij$reef_babies_used[ii-1] > 0, 6500 + 400, 0) + ifelse(sim_ij$orchard_babies_used[ii-1] > 0, 6500, 0)
        
        # get number of tiles in orchard(s)
        orch_tiles <- rep(NA, length(orchard_treatments))
        
        for(ss in 1:length(orchard_treatments)){
          orch_tiles[ss] <- sim_ij$orchard_tiles[[ss]][ii-1]
        }
        
        orch_tiles <- sum(orch_tiles)
        
        maint_costs[ii-1] <- (230/80*orch_tiles + ifelse(orch_tiles > 0, 300,0))*2# assume maintenance twice per year, and the 230/80 is the approximate cost of the maintenance (diving, labor) per substrate, 300 is the boat costs (doesn't scale with number of substrates, but is zero if there are no tiles in the orchard)
        
      }
      
     # spawn_costs <- sum(spawn_costs)
     # maint_costs <- sum(maint_costs)
      
     tot_costs <- base_costs + spawn_costs + maint_costs
     
     dt_i$tot_costs[j] <- sum(tot_costs)
      
      #dt_i$tot_dollar_costs[j]
      dt_i$reef_ROI_mean[j] <- mean(reef_cover_ij[2:max_yr]/tot_costs)
    }
    
  if(i == 1){
    dt <- dt_i
  } else{
    dt <- rbind(dt, dt_i)
  }
    
  }
  
  return(dt) # return the data frame
  
}


# data frame for all the performance metrics at year 5 (use data from time points 2 through 6)
# D0 for no disturbance simulations
orch_exp_5_D0 <- orch_exp_metric_fun(sim_list = orch_exp_list, n_sample1, L1, max_yr = 6)

View(orch_exp_5_D0)
# make this a function of the list, n_sample1, L1, and the time point of interest

# data frame for all the performance metrics at year 50 (use data from time points 2 through 51)
orch_exp_50_D0 <- orch_exp_metric_fun(sim_list = orch_exp_list, n_sample1, L1, max_yr = 51)


```



want to make some sort of plot that illustrates the trade offs between all these different objectives. x-axis is proportion outplanted to reef
maybe optimize for the different objectives, then for each optimum, plot the values of all of the objectives at that optimum?

OR: x-axis = proportion outplanted to reef, y-axis = metric scaled relative to its own max value? But does that mean max value for just that parameter combination? Max value observed across all parameter combinations? I think it would be max possible for that parameter combination since the point is to capture how the different outplanting strategies affect the success of each performance metric relative to each other. So for each parameter combination, there will be a 100% for each performance metric somewhere
-- And then pair this with plots showing the absolute values of some of the metrics?

```{r}

# try plotting individual performance metrics

dt_plot <- orch_exp_5_D0

lab_cx <- 0.85

pdf("/Users/rainedetmer/Desktop/RSE_temp_figs/metrics_5_D0.pdf", height = 7)

par(mfrow = c(3, 2))
layout(matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2, byrow = F), widths = rep(1, 2), heights = rep(1, 3))
#layout.show(2)
par(mar=c(0, 2, 3, 3), oma = c(4.5, 4.5, 2, 0))


# mean reef cover
xlab1 <- NA
ylab1 <- expression("Mean coral cover ("*m^2*")")
plotlab <- "a) Coral cover on reef"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_cover_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
mtext(side = 3, "5 year simulation, no disturbance", outer = T, line = -1)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_cover_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# recruits outplanted to reef
xlab1 <- NA
ylab1 <- "Number of recruits"
plotlab <- "b) Recruits outplanted to reef"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_recruits_out_tot, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.75, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_recruits_out_tot, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# reef ROI
xlab1 <- "Proportion substrates initially outplanted to reef"
ylab1 <- expression("Reef ROI ("*m^2~"coral/$)")
plotlab <- "c) Reef return on investment"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_ROI_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, outer = T, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_ROI_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}


# total costs
xlab1 <- NA
ylab1 <- "Total $ spent"
plotlab <- "d) Total restoration costs"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$tot_costs, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.25, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$tot_costs, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# cost to orchard reproduction (proportion of orchard reproductive potential achieved)
xlab1 <- NA
ylab1 <- "Prop. reproductive \npotential achieved"
plotlab <- "e) Orchard reproduction"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$orch_rep_cost, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.25, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$orch_rep_cost, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# orchard function
xlab1 <- NA
ylab1 <- "Mean number of \nlarge orchard corals"
plotlab <- "f) Orchard ecological function"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$orch_function_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$orch_function_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}


dev.off()

```

costs: I think the little bump up at the end is when you have to collect from the reference reef bc there's not enough in the orchard, and then it goes down again when you get to 1 because then you aren't spending anything on orchard maintenance

over 50 years: orchard has time to fill up, so see high coral cover on reef even if nothing is initially outplanted to the reef. But still see highest when you put everything on the reef because you can collect from the reference reefs

also sometimes orchard rep can go over one because of the timeing in when the orchard fills up which depends on proportion being outplanted to the orchard

```{r}


# repeat for 50 year time scale

dt_plot <- orch_exp_50_D0

lab_cx <- 0.85

pdf("/Users/rainedetmer/Desktop/RSE_temp_figs/metrics_50_D0.pdf", height = 7)

par(mfrow = c(3, 2))
layout(matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, ncol = 2, byrow = F), widths = rep(1, 2), heights = rep(1, 3))
#layout.show(2)
par(mar=c(0, 2, 3, 3), oma = c(4.5, 4.5, 2, 0))


# mean reef cover
xlab1 <- NA
ylab1 <- expression("Mean coral cover ("*m^2*")")
plotlab <- "a) Coral cover on reef"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_cover_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
mtext(side = 3, "50 year simulation, no disturbance", outer = T, line = -1)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_cover_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# recruits outplanted to reef
xlab1 <- NA
ylab1 <- "Number of recruits"
plotlab <- "b) Recruits outplanted to reef"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_recruits_out_tot, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.75, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_recruits_out_tot, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# reef ROI
xlab1 <- "Proportion substrates initially outplanted to reef"
ylab1 <- expression("Reef ROI ("*m^2~"coral/$)")
plotlab <- "c) Reef return on investment"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_ROI_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, outer = T, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$reef_ROI_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}


# total costs
xlab1 <- NA
ylab1 <- "Total $ spent"
plotlab <- "d) Total restoration costs"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$tot_costs, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.25, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$tot_costs, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# cost to orchard reproduction (proportion of orchard reproductive potential achieved)
xlab1 <- NA
ylab1 <- "Prop. reproductive \npotential achieved"
plotlab <- "e) Orchard reproduction"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$orch_rep_cost, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.25, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$orch_rep_cost, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# orchard function
xlab1 <- NA
ylab1 <- "Mean number of \nlarge orchard corals"
plotlab <- "f) Orchard ecological function"
plot(x = prop_set, y = rep(0, length(prop_set)), type = "l", col = NA, ylim = c(0, max(dt_plot$orch_function_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_out, y = dt_sub$orch_function_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}


dev.off()

```







To Do
-- update the performance metric function to record total ROI and make orchard function the area of size classes 3-5, and don't record orchard reproduction. 
-- update the performance metric function to record some kind of weighted sum of the 5 core performance metrics
-- make the same plots as before, plot the weighted sum, and plot some tradeoffs between the ones that go up vs. down the most
-- for the proportion that gives you the best weighted sum value, make ocean health index plots to show the actual values of everything at this value (outer ring is max they could be across all the proportions)

problem: if recording everything as relative to "as good as you can do", that doesn't capture if as good as you can do is still really bad...so coral cover could be a 1 but still be extremely low. Could make it relative to the goal of one per substrate surviving? Or maybe it doesn't matter? 
-- update: make radar/ocean health index plots for the highest scoring proportion to show the values of each metric

```{r}
# y = sqrt(r^r - x^2)

test_x <- seq(from = -1, to = 1, length.out = 100)

par(pty = "s")
plot(x = 1, y = 1, col = NA, xlim = c(-2, 2), ylim = c(-2, 2), asp = 1, las = 1, xlab = NA, ylab = NA, xaxt = "n", yaxt = "n")
#lines(x = test_x, y = sqrt(1 - test_x^2))
#lines(x = test_x, y = -1*sqrt(1 - test_x^2))
polygon(x = c(test_x, rev(test_x)), y = c(sqrt(1 - test_x^2), rev(-1*sqrt(1 - test_x^2)))) # , col = "gray"
# inner segment: r = 

# r^2 = x^2 + y^2

# polar coordinates:
# x = r*cos(theta)
# y = r*sin(theta)

# want inner and outer segments, each are 60 degrees
# from 0 to 60: x1 = r*cos(0), x2 = r*cos(60*pi/180)
r_in <- 0.5
th1 <- 0 # starting angle (in degrees)
th2 <- 60 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
#lines(x = r_in_x, y = sqrt(r_in^2 - r_in_x^2), col = "red")

r_out <- 1
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
#lines(x = r_out_x, y = sqrt(r_out^2 - r_out_x^2), col = "red")

polygon(x = c(r_in_x, rev(r_out_x)), y = c(sqrt(r_in^2 - r_in_x^2), rev(sqrt(r_out^2 - r_out_x^2))), col = "red")

r_in <- 0.5
r_out <- 1
th1 <- 60 # starting angle (in degrees)
th2 <- 120 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
polygon(x = c(r_in_x, rev(r_out_x)), y = c(sqrt(r_in^2 - r_in_x^2), rev(sqrt(r_out^2 - r_out_x^2))), col = "blue")

r_in <- 0.5
r_out <- 1
th1 <- 120 # starting angle (in degrees)
th2 <- 180 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
polygon(x = c(r_in_x, rev(r_out_x)), y = c(sqrt(r_in^2 - r_in_x^2), rev(sqrt(r_out^2 - r_out_x^2))), col = "orange")

# past 180: need to switch to negative square root
r_in <- 0.5
r_out <- 1
th1 <- 180 # starting angle (in degrees)
th2 <- 240 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
polygon(x = c(r_in_x, rev(r_out_x)), y = c(-sqrt(r_in^2 - r_in_x^2), rev(-sqrt(r_out^2 - r_out_x^2))), col = "orchid")

r_in <- 0.5
r_out <- 1
th1 <- 240 # starting angle (in degrees)
th2 <- 300 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
polygon(x = c(r_in_x, rev(r_out_x)), y = c(-sqrt(r_in^2 - r_in_x^2), rev(-sqrt(r_out^2 - r_out_x^2))), col = "forestgreen")

r_in <- 0.5
r_out <- 1
th1 <- 300 # starting angle (in degrees)
th2 <- 360 # ending angle (in degrees)
r_in_x <- seq(from = r_in*cos(th1*pi/180), to = r_in*cos(th2*pi/180), length.out = 100)
r_out_x <- seq(from = r_out*cos(th1*pi/180), to = r_out*cos(th2*pi/180), length.out = 100)
polygon(x = c(r_in_x, rev(r_out_x)), y = c(-sqrt(r_in^2 - r_in_x^2), rev(-sqrt(r_out^2 - r_out_x^2))), col = "dodgerblue")

# cos(90*pi/180)
# sin(90*pi/180)
# cos(0)
# sin(0)
# 180* = pi radians --> x* = pi/180 radians


```


# lab grow-out

## set up defaults

```{r}

years <- 51 # number of years in simulation
n <- 5 # number of size classes

# define size class boundaries
SC1 <- 0
SC2 <- 10
SC3 <- 100
SC4 <- 900
SC5 <- 4000

A_mids <- c((SC1 + SC2)/2, (SC2 + SC3)/2, (SC3 + SC4)/2, (SC4 + SC5)/2, 9325) # midpoint areas of each size class (cm^2); last value is the 50% quantile of observations greater than SC5 in the standardized data from the literature

A_reef <- mean(c(4492.011, 10076.67, 8943.55)) # area of the reef (very rough estimates from kml file of Fundemar's sites)

# set upt the orchard, reef, and lab treatments
orchard_treatments <- c("orchard1") # orchards (could have multiple orchards and/or orchards with different post-outplanting treatments)
reef_treatments <- c("reef1") # reef treatments/subpopulations (e.g., could have "urchin outplanting" or "algal removal" or other postoutplanting treatments)
lab_treatments <- c("0_T1", "1_T1") # lab treatments (cement = T1, ceramic = T2). "TX" is tile type, "X_" indicates whether recruits are outplanted immediately (0_) or the next year (0_1)


# demographic parameters for each orchard and reef
field_surv1 <- field_surv
field_growth1 <- field_growth
nurs_surv1 <- nurs_surv
nurs_growth1 <- nurs_growth

# nursery data only available for size classes 1-2, so use the field data for the larger size classes
nurs_surv1$SC_surv_summ_df <- nurs_surv1$SC_surv_summ_df %>% filter(size_class < 3) %>% rbind(field_surv1$SC_surv_summ_df[field_surv1$SC_surv_summ_df$size_class > 2,])

nurs_growth1$summ_list[[3]] <- field_growth1$summ_list[[3]]
nurs_growth1$summ_list[[4]] <- field_growth1$summ_list[[4]]
nurs_growth1$summ_list[[5]] <- field_growth1$summ_list[[5]]

# calculate mean parameter values (survival, growth, shrinkage, fragmentation) for each 
all_pars <- default_pars_fun(n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), summ_metric_list = list(field_surv = "mean", field_growth = "mean", field_shrink = "mean", field_frag = "mean", nurs_surv = "mean", nurs_growth = "mean", nurs_shrink = "mean"), field_surv1, field_growth1, nurs_surv1, nurs_growth1, apal_frag_summ)

# reef parameters: survival
surv_pars.r <- all_pars$surv_pars.r

# reef parameters: growth
growth_pars.r <- all_pars$growth_pars.r

# reef parameters: shrinkage
shrink_pars.r <- all_pars$shrink_pars.r

# reef parameters: fragmentation
frag_pars.r <- all_pars$frag_pars.r

# density dependent survival (smallest size class only for now)
dens_pars.r <- list()
dens_pars.r[[1]] <- list() # first reef treatment/subpop
dens_pars.r[[1]][[1]] <- 0.02 # first source to first reef (external recruits)
dens_pars.r[[1]][[2]] <- dens_pars.r[[1]][[1]] # second source to first reef (first lab treatment)
dens_pars.r[[1]][[3]] <- dens_pars.r[[1]][[1]] # third source to first reef (second lab treatment)

# reef parameters: fecundity (for tracking reef reproductive output)
# estimates of number of eggs from spawning colonies in Fundemar's data (but don't know colony sizes): min = ~5200, 25% quantile = ~30000, 50% = ~93000, 75% = ~100000, max = ~140000, mean = ~72000

# update: use Fundemar's 2025 data (table 1 of their annual report) and assume no size-dependent reproduction because 1) lack of data and 2) Fundemar said they sometimes see smaller colonies spawning the most
# from Table 1: collected 1255111 embryos (100% fertilization) from 26 colonies (26 out of 31 of their monitored colonies spawned over a period of 2 days)

fec_pars.r <- list()
fec_pars.r[[1]] <- list()
fec_pars.r[[1]][[1]] <- c(0, 0, rep(1255111/26, 3)) #c(0, 0, 5000, 50000, 100000)
fec_pars.r[[1]][[2]] <- fec_pars.r[[1]][[1]]
fec_pars.r[[1]][[3]] <- fec_pars.r[[1]][[1]]

# orchard parameters: survival
surv_pars.o <-all_pars$surv_pars.o #  list(list(c(0.8888889, 0.9314815, 0.95, 0.98, 1)))

# orchard parameters: growth
growth_pars.o <- all_pars$growth_pars.o

# orchard parameters: shrinkage
shrink_pars.o <- all_pars$shrink_pars.o

# orchard parameters: fragmentation
frag_pars.o <- all_pars$frag_pars.o

# density dependent survival (smallest size class only for now)
dens_pars.o <- list()
dens_pars.o[[1]] <- list() # first orchard
dens_pars.o[[1]][[1]] <- 0.02
dens_pars.o[[1]][[2]] <- 0.02

# orchard parameters: fecundity
fec_pars.o <- list()
fec_pars.o[[1]] <- list() # first treatment
fec_pars.o[[1]][[1]] <- c(0, 0, rep(1255111/26, 3)) # first source
fec_pars.o[[1]][[2]] <- c(0, 0, rep(1255111/26, 3)) # second source

lambda <- 0 # external recruitment to reef

#lambda_R <- 10000 # mean number of larvae produced by reference reefs each year
lambda_R <- 1255111 # from Table 1 of Fundemar's report (total embryos collected in 2025)

# stochasticity parameters
sigma_s <- 0
sigma_f <- 0
ext_rand <- c(FALSE, FALSE) # whether 1) external recruitment and 2) reference reef reproduction is stochastic 
seeds <- c(1000, 5000, 10000, 40000)

# initial conditions in each reef subpopulation
N0.r <- list()
N0.r[[1]] <- list() # second reef subpop
N0.r[[1]][[1]] <- rep(0, n) # first source (external recruits)
N0.r[[1]][[2]] <- rep(0, n) # second source
N0.r[[1]][[3]] <- rep(0, n) # third source

# initial conditions in each orchard subpopulation
N0.o <- list()
N0.o[[1]] <- list() # first orchard treatment
N0.o[[1]][[1]] <- rep(0, n) # first source
N0.o[[1]][[2]] <- rep(0, n) # second source

N0.l <- list()
N0.l[[1]] <- 0
N0.l[[2]] <- 0


# disturbance parameters
dist_yrs <- c(years + 10) # years when disturbance occurs, can set to > years for none
#dist_yrs <- c(10)


# effects of disturbance on each reef subpop
dist_effects.r <- list()
dist_effects.r[[1]] <- list() # list where each element is the effects of disturbance on corals from each source in the 1st reef subpop (either "survival" for survival, "Tmat" for growth/survival, "Fmat" for fragmentation, or "fecundity" for reproduction)
dist_effects.r[[1]][[1]] <- list() # effects of disturbances on corals from first source in first reef subpop
dist_effects.r[[1]][[1]][[1]] <- c("survival") # effects of 1st disturbance on corals from first source in first reef subpop ([[1]][[1]][[2]] would be second disturbance, etc.)
dist_effects.r[[1]][[2]] <- list() # second source
dist_effects.r[[1]][[2]][[1]] <- c("survival")
dist_effects.r[[1]][[3]] <- list() # third source
dist_effects.r[[1]][[3]][[1]] <- c("survival")


# disturbance parameters for each reef subpop (what happens to the population parameters at each disturbance eve)
dist_pars.r <- list()

# first reef population
dist_pars.r[[1]] <- list() 
# first source to first reef subpop
dist_pars.r[[1]][[1]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.r[[1]][[1]], dist_surv0 = list(surv_pars.r[[1]][[1]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL) # list of disturbance parameters for the first source to the first reef population (defaults for each parameter type are NULL unless the disturbance affects them, as specified in dist_effects)
# second source to first reef subpop (lab tiles)
dist_pars.r[[1]][[2]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.r[[1]][[2]], dist_surv0 = list(surv_pars.r[[1]][[2]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL)
dist_pars.r[[1]][[3]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.r[[1]][[3]], dist_surv0 = list(surv_pars.r[[1]][[3]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL)


# disturbance effects for each orchard subpop
dist_effects.o <- list()

dist_effects.o[[1]] <- list() 
dist_effects.o[[1]][[1]] <- list() # effects of disturbances on corals from first source in first orchard treatment
dist_effects.o[[1]][[1]][[1]] <- c("survival") # effects of 1st disturbance on corals from first source in first reef subpop ([[1]][[1]][[2]] would be second disturbance, etc.)

dist_effects.o[[1]][[2]] <- list() # effects of disturbances on corals from second source in first orchard treatment
dist_effects.o[[1]][[2]][[1]] <- c("survival") # effects of 1st disturbance on corals from first source in first reef subpop ([[1]][[1]][[2]] would be second disturbance, etc.)


# disturbance parameters for each orchard subpop
dist_pars.o <- list()

# first orchard treatment
dist_pars.o[[1]] <- list() 
# first source in first orchard treatment
dist_pars.o[[1]][[1]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.o[[1]][[1]], dist_surv0 = list(surv_pars.o[[1]][[1]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL) 
# second source in first orchard
dist_pars.o[[1]][[2]] <- dist_pars_fun(dist_yrs = dist_yrs, dist_effects.o[[1]][[2]], dist_surv0 = list(surv_pars.o[[1]][[2]]*0.1), dist_Tmat0 = NULL, dist_Fmat0 = NULL, dist_fec0 = NULL) 



# lab parameters
# fractions of settled larvae in each lab treatment that survive to immediate outplanting each year
s0 <- matrix(NA, nrow = years, ncol = 2)
s0[,1] <- rep(0.95, years)
s0[,2] <- rep(0.95, years)

#s0[10,1] <- 0.05
#s0[10,2] <- 0.05

# fractions of settled larvae in each lab treatment that survive to 1 yr outplanting
s1 <- matrix(NA, nrow = years, ncol = 2)
s1[,1] <- rep(0.7, years)
s1[,2] <- rep(0.7, years)

m0 <- c(0.02, 0.02) # density dependent mortality rate of larvae in each lab treatment that get outplanted immediately
m1 <- c(0.02, 0.02) # density dependent mortality rate of larvae in each lab treatment that get outplanted after 1 year
#sett_props <- list(T1 = 0.15, T2 = 0.15) # proportion of larvae that settle on each tile type
sett_props <- list(T1 = 0.15) # proportion of larvae that settle on each tile type
size_props <- matrix(NA, nrow = length(lab_treatments), ncol = n) # matrix for fractions of retained recruits in each size class at the end of their year in the lab
size_props[1, ] <- c(1, 0, 0, 0, 0) # first lab treatment (0_T1)
size_props[2, ] <- c(1, 0, 0, 0, 0) # second lab treatment (0_T2)
lab_pars <- list(s0 = s0, s1 = s1, m0 = m0, m1 = m1, sett_props = sett_props, size_props = size_props)

# restoration strategy parameters
tile_props <- list(T1 = 1) # proportion of tiles that are each type
orchard_yield <- 1 # percent of new orchard babies successfully collected
reef_yield <- 1 # percent of new reef babies successfully collected and fertilized
spawn_target <- 2000000 # target number of embryos to collect from orchard each year (note: if this is set to zero, there won't be any settlers)
reef_prop <- c(1, 1) # proportion of lab recruits from each lab treatment outplanted to reef (1-proportion outplanted to orchard)
reef_out_props <- matrix(NA, nrow = length(lab_treatments), ncol = length(reef_treatments)) # proportion recruits going from each lab treatment to each reef treatment (row = origin lab treatment, column = destination reef treatment)
reef_out_props[1,] <- c(1) # from first lab treatment to each reef treatment (here there's just on intervention reef so they all go there)
reef_out_props[2,] <- c(1) # from second lab treatment to each reef treatment 

orchard_out_props <- matrix(NA, nrow = length(lab_treatments), ncol = length(orchard_treatments)) # proportion recruits going from each lab treatment to each orchard treatment
orchard_out_props[1,] <- c(1) # from first lab treatment to each orchard 
orchard_out_props[2,] <- c(1) # from second lab treatment to each orchard 

# sizes allocated to each treatment
reef_areas <- c(A_reef)*10000 # m^2 given to each post-outplanting reef treatment/subpopulation, convert to cm^2 by multiplying by 10,000
lab_max <- 3100 # total number of tiles that the lab can accommodate 
lab_retain_max <- 10 # total number of tiles that the lab can keep for a year (must be less than or equal to lab_max; if > 0 then must have at least one "1_" lab treatment, if equal to lab max then must have all treatments be "1_")
tank_min <- 14600 # min number of embryos to put in a tank (reduce number of tanks used if less than this to avoid unrealistically small densities on the tiles)
tank_max <- 33333 # max number of embryos to put in a tank (impose a max because in reality if you had unlimited embryos you wouldn't put all of them in tanks because the density would be too high and presumably lead to high dens dep mortality). Chose max to correspond to number that would result in 50 embryos per tile, assuming 15% settlement and 100 tiles per tank

# 100*50/0.15

orchard_size <- c(30*500) # number of tiles each orchard has space for (500 stars x 30 tiles per star)


# coral transplanting
transplant <- rep(0, years) # years in which corals get transplanted from the orchard
#transplant[10] <- 1 # in 10th year, move corals from orchard to reef

null_mat <- matrix(0, nrow = years, ncol = n)
#rest_pars$trans_mats[[1]][[1]][which(transplant!=0)[1],] <- c(0, 0, 0, 2,0)# max number of colonies of each size class to move to reef in first transplant event
trans_mats <- list()
trans_mats[[1]] <- list() # first orchard 
trans_mats[[1]][[1]] <- null_mat # number of corals in each size class that originated from the first source of colonies for this orchard to transplant at each timepoint
trans_mats[[1]][[2]] <- null_mat # number of corals in each size class that originated from the second source of colonies for this orchard to transplant at each timepoint

# where on the reef to put the transplants
#rest_pars$trans_reef[[1]][[1]][which(transplant!=0)[1],] <- c(1, 1)# reef and source subpop to transport the corals to
trans_reef <- list()
trans_reef[[1]] <- list() # first orchard
trans_reef[[1]][[1]] <- matrix(c(1, 2), nrow = years, ncol = 2, byrow = T) # first source corals in this orchard get transplanted to the second source of corals in the first reef
trans_reef[[1]][[2]] <- matrix(c(1, 3), nrow = years, ncol = 2, byrow = T) # second source corals in this orchard get transplanted to the third source of corals in the second reef

rest_pars <- list(tile_props = tile_props, orchard_yield = orchard_yield, reef_yield = reef_yield, spawn_target = spawn_target, reef_prop = reef_prop, reef_out_props = reef_out_props, orchard_out_props = orchard_out_props, reef_areas = reef_areas, lab_max = lab_max, lab_retain_max = lab_retain_max, tank_min = tank_min, tank_max = tank_max, orchard_size = orchard_size, transplant = transplant, trans_mats = trans_mats, trans_reef = trans_reef)


sim1 <- rse_mod1(years, n, A_mids, surv_pars.r, dens_pars.r, growth_pars.r, shrink_pars.r, frag_pars.r, fec_pars.r, surv_pars.o, dens_pars.o, growth_pars.o, shrink_pars.o, frag_pars.o, fec_pars.o, lambda, lambda_R, sigma_s, sigma_f, ext_rand, seeds, dist_yrs, dist_pars.r, dist_effects.r, dist_pars.o, dist_effects.o, orchard_treatments, reef_treatments, lab_treatments, lab_pars, rest_pars, N0.r, N0.o, N0.l)

```


check output

```{r}


#sim1$reef_out[[1]][[2]]

#(sim1$reef_out[[1]][[2]])/sim1$tiles_out_tot


#sim1$tiles_out_tot

reef1_tot <- model_summ(model_sim = sim1, location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

orch1_tot <- model_summ(model_sim = sim1, location = "orchard", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(max(reef1_tot), max(orch1_tot))), xlab = "year", ylab = "Area covered", lwd = 2)
lines(x = c(1:years), y = orch1_tot, type = "l", col = "dodgerblue", lwd = 2, lty = 2)
legend("topleft", legend = c("reef", "orchard"), col = c("black", "dodgerblue"), lwd = 2, lty = c(1, 2))


reef1_tot <- model_summ(model_sim = sim1, location = "reef", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

orch1_tot <- model_summ(model_sim = sim1, location = "orchard", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(max(reef1_tot), max(orch1_tot))), xlab = "year", ylab = "Population size", lwd = 2)
lines(x = c(1:years), y = orch1_tot, type = "l", col = "dodgerblue", lwd = 2, lty = 2)
legend("topleft", legend = c("reef", "orchard"), col = c("black", "dodgerblue"), lwd = 2, lty = c(1, 2))


plot(x = c(1:years), y = reef1_tot, type = "l", las = 1, ylim = c(0, max(reef1_tot)), xlab = "year", ylab = "Area covered", lwd = 2)

plot(x = c(1:years), y = sim1$reef_out[[1]][[2]], type = "l", ylim = c(0, max(max(sim1$reef_out[[1]][[2]], na.rm = T), max(sim1$orchard_out[[1]][[1]], na.rm = T))))
lines(x = c(1:years), y = sim1$orchard_out[[1]][[1]], col = "dodgerblue")

sim1$reef_out

```



```{r}

plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][1,], type = "l")
plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][2,], type = "l")
plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][3,], type = "l")
plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][4,], type = "l")
plot(x = c(1:years), y = sim1$orchard_pops[[1]][[1]][5,], type = "l")

sim1$orchard_out[[1]][[1]]

# It looks like the problem is maybe just that some of the orchard corals are dying but there are still at least one per tile so nothing new is being outplanted but the total number in the orchard is decreasing

```



maybe start with simplest case: 5 year timeline, no orchard? (because adding the orchard and how well they do in orchard vs. lab is another layer). And then look at 10 years or something to see if bet hedging takes longer to show up


maybe some sort of plot with relative survival of grow-out outplants (compared to those outplanted immediately) on the x-axis and relative growth on the y-axis? And then show optimal proportion of tiles to keep in lab?

```{r}
# update random parameters to have two lab treatments

# number of iterations
#n_sample1 <- 100

# full parameter sets
field_surv1 <- field_surv
field_growth1 <- field_growth
nurs_surv1 <- nurs_surv
nurs_growth1 <- nurs_growth

# nursery data only available for size classes 1-2, so use the field data for larger size classes
nurs_surv1$SC_surv_df <- nurs_surv1$SC_surv_df %>% filter(size_class < 3) %>% rbind(field_surv1$SC_surv_df[field_surv1$SC_surv_df$size_class > 2,])

nurs_growth1$mat_list[[3]] <- field_growth1$mat_list[[3]]
nurs_growth1$mat_list[[4]] <- field_growth1$mat_list[[4]]
nurs_growth1$mat_list[[5]] <- field_growth1$mat_list[[5]]

set.seed(500)
all_pars_R2 <- rand_pars_fun(n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), n_sample = n_sample1, field_surv = field_surv1, field_growth = field_growth1, nurs_surv = nurs_surv1, nurs_growth = nurs_growth1, apal_frag)
```


```{r}

# but also need to iterate over differences in survival/growth in reef vs. lab

# just start with differences in survival for now

L1 <- 10
prop_retain <- seq(from = 0, to = 1, length.out = L1) # proportion tiles to keep in the lab for grow-out

lab_grow_list <- list()


# outer loop = demographic parameter values
# inner loop = proportion to outplant to the reef

tic()

for(i in 1:n_sample1){ # for each parameter set
  
  # set up the parameters
  
  surv_pars.r <- all_pars_R2$surv_pars_L.r[[i]] 
  growth_pars.r <- all_pars_R2$growth_pars_L.r[[i]]
  shrink_pars.r <- all_pars_R2$shrink_pars_L.r[[i]] 
  frag_pars.r <- all_pars_R2$frag_pars_L.r[[i]]
  surv_pars.o <- all_pars_R2$surv_pars_L.o[[i]] 
  growth_pars.o <- all_pars_R2$growth_pars_L.o[[i]]
  shrink_pars.o <- all_pars_R2$shrink_pars_L.o[[i]]
  frag_pars.o <- all_pars_R2$frag_pars_L.o[[i]]
  
  # update field survival of the grow-out tiles (smallest size class only for now)
  surv_pars.r[[1]][[3]][1] <- min((surv_pars.r[[1]][[2]][1] + 0.001)*5, 1)
 # surv_pars.r[[1]][[3]][2] <- min((surv_pars.r[[1]][[2]][2] + 0.001)*1.5, 1)
  
  # holding list for model simulations with this parameter set
  mod_list <- list()
  
  for(j in 1:length(prop_retain)){ # for each proportion outplanted to reef
    
    
    rest_pars_ij <- rest_pars
    
    rest_pars_ij$lab_retain_max <- lab_max*prop_retain[j] # proportion of tiles outplanted to reef
    
    # run the model
    sim_ij <- rse_mod1(years, n, A_mids, surv_pars.r, dens_pars.r, growth_pars.r, shrink_pars.r, frag_pars.r, fec_pars.r, surv_pars.o, dens_pars.o, growth_pars.o, shrink_pars.o, frag_pars.o, fec_pars.o, lambda, lambda_R, sigma_s, sigma_f, ext_rand, seeds, dist_yrs, dist_pars.r, dist_effects.r, dist_pars.o, dist_effects.o, orchard_treatments, reef_treatments, lab_treatments, lab_pars, rest_pars_ij, N0.r, N0.o, N0.l)
    
    
    # save the output
    mod_list[[j]] <- sim_ij
    
  } # end of iterations over outplanting proportions
  
  
  lab_grow_list[[i]] <- mod_list
  
} # end of iterations over parameter sets

toc()



```


```{r}

# function for extracting performance metrics from the lab grow-out simulations
lab_grow_metric_fun <- function(sim_list, n_sample1, L1, max_yr){
  
  
  # calculate the performance metrics for each parameter combination
  for(i in 1:n_sample1){ # for each parameter combination
    
    # make the holding data frame
    dt_i <- data.frame(
  par_rep = rep(i, L1), # random parameter replicate
  prop_retain = rep(NA, L1), # proportion tiles retained in lab
  reef_cover_mean = rep(NA, L1), # m2 of coral cover on reef (mean over years 1-max_yr)
  reef_cover_sd = rep(NA, L1), # variability in coral cover on reef (sd over years 1-max_yr)
  reef_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals on reef
  reef_function_sd = rep(NA, L1), # variability in number of large corals on reef
  reef_tiles_out_tot = rep(NA, L1), # total number of tiles outplanted to reef
  reef_area_out_tot = rep(NA, L1), # total area of reef over which tiles were outplanted 
  reef_recruits_out_tot = rep(NA, L1), # total recruits outplanted to reef
  reef_ROI_mean = rep(NA, L1), # corals on reef per dollar spent, averaged over max_yr years
 # tot_dollar_costs = rep(NA, L1), # total amount of money spent on restoration over max_yr years 
 tot_costs <- rep(NA, L1)#, # total amount spent over length of simulation
 # reef_cover_cost = rep(NA, L1), # avg coral cover on reef over max_yr years compared to if all corals were put on the reef
 # orch_rep_cost = rep(NA, L1), # avg orchard reproduction over max_yr years compared to if all corals were put in the orchard
 # orch_function_mean = rep(NA, L1), # avg number of large (size classes 4-5) corals in orchard
 # orch_function_sd = rep(NA, L1) # variability in number of large corals in orchard
)
    
    # NOTE: could make coral cover per m2 where m2 is the total area outplanted up to that time point, but then you might get numbers that look high if very few tiles were outplanted so that might be too confusing...
    
    # get max reef and orchard values for calculating costs
  #  orch_rep_0 <- model_summ(model_sim = sim_list[[i]][[1]], location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
    
  #  orch_rep_max <- mean(orch_rep_0[2:max_yr], na.rm = T)
    
    reef_cover_1 <- model_summ(model_sim = sim_list[[i]][[L1]], location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
    
    reef_cover_max <- mean(reef_cover_1[2:max_yr], na.rm = T)
    
    for(j in 1:L1){ # for each proportion outplanted to reef
      
      sim_ij <- sim_list[[i]][[j]]
      
      # reef cover
      reef_cover_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "area_m2", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))
      
      # reef function
      reef_fun_ij <- model_summ(model_sim = sim_ij, location = "reef", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))

      # orchard rep
#orch_rep_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "production", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments))

      # orchard function
#orch_fun_ij <- model_summ(model_sim = sim_ij, location = "orchard", metric = "ind", n_reef = length(reef_treatments), n_orchard = length(orchard_treatments), n_lab = length(lab_treatments), size_classes = c(4, 5))

      dt_i$prop_retain[j] <- prop_retain[j]
      dt_i$reef_cover_mean[j] <- mean(reef_cover_ij[2:max_yr], na.rm = T)
      dt_i$reef_cover_sd[j] <- sd(reef_cover_ij[2:max_yr], na.rm = T)
      dt_i$reef_function_mean[j] <- mean(reef_fun_ij[2:max_yr], na.rm = T)
      dt_i$reef_function_sd[j] <- sd(reef_fun_ij[2:max_yr], na.rm = T)
      dt_i$reef_tiles_out_tot[j] <- sum(sim_ij$reef_tiles_out[2:max_yr], na.rm = T)
      dt_i$reef_area_out_tot[j] <- dt_i$reef_tiles_out_tot[j]*5
      dt_i$reef_recruits_out_tot[j] <- sum(c(sim_ij$reef_out[[1]][[2]][2:max_yr], sim_ij$reef_out[[1]][[3]][2:max_yr]), na.rm = T)
      dt_i$reef_cover_cost[j] <- dt_i$reef_cover_mean[j]/reef_cover_max
     # dt_i$orch_rep_cost[j] <- mean(orch_rep_ij[2:max_yr], na.rm = T)/orch_rep_max
     # dt_i$orch_function_mean[j] <- mean(orch_fun_ij[2:max_yr], na.rm = T)
     # dt_i$orch_function_sd[j] <- sd(orch_fun_ij[2:max_yr], na.rm = T)
      
      # costs: baseline cost per reef star ($84.6), yearly costs of tiles ($1 per cement and $7 per ceramic; use same ratio as in 2025 which was 50-50), cost of orchard maintenance is currently $530 per day and they have ~80 reef stars, so assume this scales linearly with number of substrates in the orchard and that with the reef stars they need to do this maintenance twice a year. But that $530 includes the boat, and later say transportation is 300 per day with their boat for maintenance and reef star seeding... so only make $230 scale with number of substrates in orchard, and have the 300 (boat) be the twice per year maintenance costs
      # QUESTION: how will maintenance costs scale with number of substrates in the orchard?
      # outplanting costs (estimated from transportation and diving costs): 300 per day for boat + 200 per day for 4 divers. For now assume it just takes one day for each (so double if you are outplanting to both the reef and orchard)
      # QUESTION: how many substrates can be outplanted to orchard and intervention reef per day
      # lab costs: $443/d for first week, then $200/d for following weeks, so a total of 432*7 + 200*(7*3) per month. But here assuming they are outplanted quickly so just use the 443*7 + 200*7 = 4501
      # boat maintenance: 1200 every 3 months = 4800 per year
      # logistics: 500 per month = 6000 per year
      # diver costs: gave costs per dive but not sure about how many dives per year. Ignore non-outplanting/spawning collection/maintenance dives for now
      # larval collection costs: 6,500 per spawning event on reference reefs, 400 per year for permits. Assume you don't need permits 
      # QUESTION: how do think the costs of larval collection in the orchard will compare to collection from the reference reefs? (e.g., won't need permits?)
      
      # QUESTION: how do lab costs scale with the number of substrates kept in the lab? For now assume 3000 tiles and calculate cost per tile? OR maybe the thing to vary is how long they are kept in the lab?
      
      # baseline costs
    # outplanting costs
    if(reef_prop[1] > 0 & reef_prop[1] < 1){ # if there is outplanting to both orch and reef
        out_costs <- 2*(300 + 200)
        
      } else{
        
        out_costs <- 1*(300 + 200) # outplanting to one place only
      }
    
   # base_costs <- (rest_pars$lab_max*(0.5*1 + 0.5*7) + 4501 + out_costs + 4800 + 6000)*length(2:max_yr)
    
    base_costs <- (rest_pars$lab_max*(0.5*1 + 0.5*7) + out_costs + 4800 + 6000)*length(2:max_yr)
     # lab costs = cost of keeping tiles in the lab 
    lab_costs <- (1-prop_retain[j])*(443*7 + 200*7)/rest_pars$lab_max + (prop_retain[j])*(443*7 + 200*7*24)/rest_pars$lab_max # assume they are kept in lab for 6 months = 24 weeks
    
    # add the initial costs (costs of reef stars) to year 1
   # base_costs[1] <- 84.6*rest_pars$orchard_size/30
      
      spawn_costs <- rep(NA, length(2:max_yr)) # collecting costs
     # maint_costs <- rep(NA, length(2:max_yr)) # costs of orchard maintenance
      
      for(ii in 2:max_yr){
        spawn_costs[ii-1] <- ifelse(sim_ij$reef_babies_used[ii-1] > 0, 6500 + 400, 0) + ifelse(sim_ij$orchard_babies_used[ii-1] > 0, 6500, 0)
        
        # get number of tiles in orchard(s)
        # orch_tiles <- rep(NA, length(orchard_treatments))
        # 
        # for(ss in 1:length(orchard_treatments)){
        #   orch_tiles[ss] <- sim_ij$orchard_tiles[[ss]][ii-1]
        # }
        # 
        # orch_tiles <- sum(orch_tiles)
        
       # maint_costs[ii-1] <- (230/80*orch_tiles + ifelse(orch_tiles > 0, 300,0))*2# assume maintenance twice per year, and the 230/80 is the approximate cost of the maintenance (diving, labor) per substrate, 300 is the boat costs (doesn't scale with number of substrates, but is zero if there are no tiles in the orchard)
        
      }
      
     # spawn_costs <- sum(spawn_costs)
     # maint_costs <- sum(maint_costs)
      
     tot_costs <- base_costs + spawn_costs + lab_costs# + maint_costs
     
     dt_i$tot_costs[j] <- sum(tot_costs)
      
      #dt_i$tot_dollar_costs[j]
      dt_i$reef_ROI_mean[j] <- mean(reef_cover_ij[2:max_yr]/tot_costs)
    }
    
  if(i == 1){
    dt <- dt_i
  } else{
    dt <- rbind(dt, dt_i)
  }
    
  }
  
  return(dt) # return the data frame
  
}


# data frame for all the performance metrics at year 5 (use data from time points 2 through 6)
# D0 for no disturbance simulations
lab_grow_5_D0 <- lab_grow_metric_fun(sim_list = lab_grow_list, n_sample1, L1, max_yr = 6)

# make this a function of the list, n_sample1, L1, and the time point of interest

# data frame for all the performance metrics at year 50 (use data from time points 2 through 51)
lab_grow_50_D0 <- lab_grow_metric_fun(sim_list = lab_grow_list, n_sample1, L1, max_yr = 51)


```



```{r}

# plot results
# show reef cover, recruits outplanted, ROI, and total costs

# repeat for 50 year time scale

dt_plot <- lab_grow_5_D0

lab_cx <- 0.85

pdf("/Users/rainedetmer/Desktop/RSE_temp_figs/metrics_grow_5_D0.pdf", height = 7)

par(mfrow = c(3, 2))
layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = F), widths = rep(1, 2), heights = rep(1, 2))
#layout.show(2)
par(mar=c(0, 2, 3, 3), oma = c(4.5, 4.5, 2, 0))


# mean reef cover
xlab1 <- NA
ylab1 <- expression("Mean coral cover ("*m^2*")")
plotlab <- "a) Coral cover on reef"
plot(x = prop_retain, y = rep(0, length(prop_retain)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_cover_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 2.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
mtext(side = 3, "5 year simulation, no disturbance", outer = T, line = -1)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_retain, y = dt_sub$reef_cover_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# recruits outplanted to reef
xlab1 <- NA
ylab1 <- "Number of recruits"
plotlab <- "b) Recruits outplanted to reef"
plot(x = prop_retain, y = rep(0, length(prop_retain)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_recruits_out_tot, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.75, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_retain, y = dt_sub$reef_recruits_out_tot, col = adjustcolor(col = "black", alpha.f = 0.2))
}

# reef ROI
xlab1 <- "Proportion substrates retained in lab"
ylab1 <- expression("Reef ROI ("*m^2~"coral/$)")
plotlab <- "c) Reef return on investment"
plot(x = prop_retain, y = rep(0, length(prop_retain)), type = "l", col = NA, ylim = c(0, max(dt_plot$reef_ROI_mean, na.rm = T)), las = 1, xlab = NA, ylab = NA)
mtext(side = 1, xlab1, line = 2.5, outer = T, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.5, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_retain, y = dt_sub$reef_ROI_mean, col = adjustcolor(col = "black", alpha.f = 0.2))
}


# total costs
xlab1 <- NA
ylab1 <- "Total $ spent"
plotlab <- "d) Total restoration costs"
plot(x = prop_retain, y = rep(0, length(prop_retain)), type = "l", col = NA, ylim = c(0, max(dt_plot$tot_costs, na.rm = T)), las = 1, xlab = NA, ylab = NA)
# min(dt_plot$tot_costs, na.rm = T)
mtext(side = 1, xlab1, line = 2.5, cex = lab_cx)
mtext(side = 2, ylab1, line = 3.25, cex = lab_cx)
mtext(side = 3, plotlab, adj = 0)
for(i in 1:n_sample1){
  dt_sub <- dt_plot[which(dt_plot$par_rep==i),]
  lines(x = dt_sub$prop_retain, y = dt_sub$tot_costs, col = adjustcolor(col = "black", alpha.f = 0.2))
}



dev.off()

```


should change this to vary length of time the tiles are kept in the lab (from a few months to a year) and then play with assumptions about how survival/growth scale with length of time kept in the lab. Assume fixed proportions of substrates are retained, e.g., 50%



