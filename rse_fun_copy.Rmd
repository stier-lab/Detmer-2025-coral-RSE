---
title: "rse_fun_copy"
author: "Raine Detmer"
date: "2025-07-02"
output: html_document
---

README: place to copy paste the model function for debugging and to think through model additions

more simplified function without a dynamic reference reef


```{r}
  
  # reef subpops = length(lab_treatments)*length(reef_treatments)
  # lab subpops = length(lab_treatments)
  
  # orchard subpopulations:
  s_orchard <- length(orchard_treatments)
  
  # reef subpopulations:
  s_reef <- length(reef_treatments)
  
  # external recruitment each year
  ext_rec <- Ext_fun(years, lambda, rand = ext_rand[1], seed1 = seeds[3])
  # proportions going to each reef subpop (proportional to areas of each reef):
  # FIX: Protect against division by zero when reef_areas sum to zero
  reef_area_sum <- sum(rest_pars$reef_areas)
  if(reef_area_sum > 0) {
    ext_props <- rest_pars$reef_areas / reef_area_sum
  } else {
    ext_props <- rep(0, length(rest_pars$reef_areas))
  }
  
  # larvae collected from reference reef each year
  ref_babies <- Ext_fun(years, lambda_R, rand = ext_rand[2], seed1 = seeds[4])
  
  # update with disturbance effects
  for(i in dist_yrs){
    
    if("survival" %in% dist_effects.r[[which(dist_yrs==i)]][[1]][[1]]){ # if the ith disturbance affected survival on the reefs
      # assume that reproduction in the reference reef was decreased proportional to the average proportion survival of reproductive size classes (classes 3-5)
      ref_babies[i] <- ref_babies[i]*mean(dist_pars.r[[1]][[1]]$dist_surv[[which(dist_yrs==i)]][3:5])
    }

  }
  
  
  
  # lab subpopulations
  s_lab <- length(lab_treatments)
  # subpopulations that will be outplanted immediately
  #s_lab0 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "0"))
  # subpopulations that are retained in the lab for a year
  s_lab1 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "1")) # "1_TX" = outplanted after 1 yr, "0_TX" = outplanted in same year
  
  # tile types
  tile_types <- rep(NA, s_lab)
  
  for(ss in 1:s_lab){
    tile_types[ss] <- substr(lab_treatments[ss], start = 3, stop = 4) # T1, T2, etc.
  }
  
  # make sure there's no duplicates:
  #tile_types = unique(tile_types)
  
  # holding vectors for recording total babies collected from orchard and reference reefs each year
  orchard_babies <- rep(NA, years) # babies collected from the orchard
  reef_babies <- rep(NA, years) # babies collected from reference reef
  
  orchard_babies[1] <- 0 # babies collected from the orchard
  reef_babies[1] <- 0 # babies collected from reference reef
  
  # holding vectors for recording total babies from orchard and reference reefs that were used year
  orchard_babies_used <- rep(NA, years) # babies collected from the orchard
  reef_babies_used <- rep(NA, years) # babies collected from reference reef
  
  orchard_babies_used[1] <- 0 # babies collected from the orchard
  reef_babies_used[1] <- 0 # babies collected from reference reef
  
  
  # holding vectors for total number of tiles being outplanted each year
  tiles_out0 <- rep(NA, years) # tiles outplanted immediately
  tiles_out1 <- rep(NA, years) # tiles outplanted after lab grow-out
  tiles_out_tot <- rep(NA, years) # total tiles
  tiles_out0[1] <- 0
  tiles_out1[1] <- 0
  reef_tiles_out <- rep(NA, years) # tiles outplanted to reef each year
  orchard_tiles_out <- rep(NA, years) # tiles outplanted to orchard each year
  reef_tiles_out[1] <- 0 # tiles outplanted to reef each year
  orchard_tiles_out[1] <- 0 # tiles outplanted to orchard each year
  
  
  # sources of new recruits
  source_reef <- 1 + s_lab # number of possible sources of reef recruits (+1 is for external recruits)
  source_orchard <- s_lab # number of possible sources of orchard recruits
  
  # set up holding lists
  reef_pops <- list() # holding list for population sizes of each reef subpopulation
  reef_rep <- list() # holding list for total reproductive output from each reef subpopulation
  reef_mat_pars <- list() # list with data frames with the transition matrix parameters for each reef subpop
  reef_out <- list() # number of recruits outplanted to reef
  reef_pops_pre <- list() # reef population sizes before outplanting
  
  for(ss in 1:s_reef){
    
    # sublists for all the different sources of recruits to this reef
    reef_pops_ss <- list() # population sizes
    reef_rep_ss <- list() # total reproductive output
    reef_out_ss <- list() # numbers outplanted
    reef_pops_pre_ss <- list() # population sizes before outplanting
    reef_mat_pars_ss <- list() # matrix parameters
      
      for(rr in 1:source_reef){ # for each possible source of recruits to this reef subpop
        
        # holding matrix for number of individuals in each size class of the ss^th reef subpop from the rr^th source in each year
        reef_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
        
        # holding matrix for total reproductive output by individuals in the ss^th reef subpop from the rr^th source each year
        reef_rep_ss[[rr]] <- rep(NA, years)
        
        # holding matrix for number of recruits outplanted
        reef_out_ss[[rr]] <- rep(NA, years)
        
        # holding matrix reef population size before outplanting
        reef_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
        
        # add initial conditions
        reef_pops_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        reef_pops_pre_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        
        # and get the list with the transition matrix parameters
        reef_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[rr]], growth_pars.r[[ss]][[rr]],
                                               shrink_pars.r[[ss]][[rr]], frag_pars.r[[ss]][[rr]], fec_pars.r[[ss]][[rr]],
                                               sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[rr]],
                                               dist_effects.r[[ss]][[rr]])
        # fill in initial reproduction
        reef_rep_ss[[rr]][1] <- sum(reef_pops_ss[[rr]][,1]*reef_mat_pars_ss[[rr]]$fecundity[[1]])
        
      }
      
    
    # put all the sublists in the outer holding lists for each reef subpop
    
    reef_pops[[ss]] <- reef_pops_ss
    reef_pops_pre[[ss]] <- reef_pops_pre_ss
    reef_rep[[ss]] <- reef_rep_ss
    reef_out[[ss]] <- reef_out_ss
    reef_mat_pars[[ss]] <- reef_mat_pars_ss
    
    
  }
  
  # repeat for orchard subpops
  orchard_pops <- list()
  orchard_pops_pre <- list()
  orchard_rep <- list()
  orchard_out <- list()
  orchard_mat_pars <- list()
  
  orchard_tiles <- list() # number of tiles in each orchard
  
  for(ss in 1:s_orchard){
    
    # sublists for all the different sources of recruits to the orchard
    orchard_pops_ss <- list() # population sizes
    orchard_pops_pre_ss <- list() # population sizes before outplanting
    orchard_rep_ss <- list() # total reproductive output
    orchard_out_ss <- list() # numbers outplanted
    orchard_mat_pars_ss <- list() # matrix parameters
    
    orchard_tiles[[ss]] <- rep(NA, years)
    
    for(rr in 1:source_orchard){ # for each source of recruits to the ss^th orchard treatment
      
      # holding matrix for number of individuals in each size class of the ss^th reef subpop in each year
      orchard_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for number of individuals before outplanting
      orchard_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for total reproductive output by ss^th subpop each year
      orchard_rep_ss[[rr]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted 
      orchard_out_ss[[rr]] <- rep(NA, years)
      
      # add initial conditions here too
      orchard_pops_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      orchard_pops_pre_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      
      # and calculate the data frames with the transition matrix parameters
      orchard_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.o[[ss]][[rr]], growth_pars.o[[ss]][[rr]],
                                                shrink_pars.o[[ss]][[rr]], frag_pars.o[[ss]][[rr]],
                                                fec_pars.o[[ss]][[rr]], sigma_s, sigma_f, seeds, dist_yrs,
                                                dist_pars.o[[ss]][[rr]], dist_effects.o[[ss]][[rr]])
      # fill in initial reproduction
      orchard_rep_ss[[rr]][1] <- sum(orchard_pops_ss[[rr]][,1]*orchard_mat_pars_ss[[rr]]$fecundity[[1]])
      
      
    }
    
    
    orchard_pops[[ss]] <- orchard_pops_ss
    orchard_pops_pre[[ss]] <- orchard_pops_pre_ss
    orchard_rep[[ss]] <- orchard_rep_ss
    orchard_out[[ss]] <- orchard_out_ss
    orchard_mat_pars[[ss]] <- orchard_mat_pars_ss
    
    orchard_tiles[[ss]][1] <- sum(unlist(N0.o[[ss]])) # assume initial number of tiles = initial number of corals in orchard
    
  }
  
  
  # lab subpopulations
  lab_pops <- list()
  
  for(ss in 1:s_lab){
    
    # holding vectors for number of individuals in the ss^th lab treatment
    lab_pops[[ss]] <- rep(NA, years)
    
    # initial conditions
    lab_pops[[ss]][1] <- N0.l[[ss]]
    
  }
  
  
  
  # get the density dependent mortality parameters 
  
  # reef
  dd_pars.r <- matrix(NA, nrow = s_reef, ncol = s_lab)
  for(ss in 1:s_reef){
    
    for(rr in 1:s_lab){ # for each lab source (rr = 1 is for external recruits)
      
      dd_pars.r[ss, rr] <- dens_pars.r[[ss]][[rr + 1]]
    }
    
  }
  
  # orchard
  dd_pars.o <- matrix(NA, nrow = s_orchard, ncol = s_lab)
  for(ss in 1:s_orchard){
    
    for(rr in 1:source_orchard){ # for each lab source (rr = 1 is for external recruits)
      
      dd_pars.o[ss, rr] <- dens_pars.o[[ss]][[rr]]
    }
    
  }
  
  for(i in 2:years){
    
    
    # steps:
    # 1) corals from previous year grow/die and external recruits settle on the reefs
    # 2) corals reproduce and orchard babies are collected and go to lab
    # 3) add lab recruits from same year and/or previous year 
    
    # restoration model: determines how many recruits/corals go in each treatment
    # should also keep track of the costs of each treatment (doesn't yet)
    # possible feedbacks (currently none) = numbers going in to each treatment depends on population sizes, env., etc.
    
    # reef dynamics
    
    # update the population size using the transition matrix:
    
    for(ss in 1:s_reef){ # for each reef subpopulation
        
        for(rr in 1:source_reef){ # for each source of recruits to this reef
          
          # get the transition matrix (growth, shrinkage, staying)
          T_mat <- reef_mat_pars[[ss]][[rr]]$growth[[i]]
          
          # get the fragmentation matrix
          F_mat <- reef_mat_pars[[ss]][[rr]]$fragmentation[[i]]
          
          # if the reef is full, assume none of the fragments produced over the last year result in new colonies
          # if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
          #   F_mat <- 0*F_mat
          # }
          
          # get the survival probabilities
          S_i <- reef_mat_pars[[ss]][[rr]]$survival[[i]] # survival
          
        
          # update survival of the smallest size class with density dependence: 
          # first need to get total population size across all size classes and sources to this reef subpopulation
          # N_all <- rep(NA, source_reef)
          # 
          # for(rrr in 1:source_reef){
          #   N_all[rrr] <- sum(reef_pops[[ss]][[rrr]][,i-1])
          # }
          # 
          # # now update survival based on the total population size on this reef
          # S_i[1] <- S_i[1]*exp(-dens_pars.r[[ss]][[rr]]*sum(N_all))
          
          N_mat <- reef_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
          N_mat <- N_mat*S_i # fractions surviving to current time point
          
          # now update the population sizes
          reef_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes
          
          # record this as the pre-outplant population size (population size before lab settlers are outplanted)
          reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          
          # amount of new larvae produced by this reef population at the i^th time point:
          reef_rep[[ss]][[rr]][i] <- sum(reef_pops[[ss]][[rr]][ ,i]*reef_mat_pars[[ss]][[rr]]$fecundity[[i]])
          
          if(rr ==1){ # if this is the first source (external recruits)
            # add the external recruits if they fit
            # tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
            # occupied_area1 <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids) # total area currently occupied
            # open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
            # new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need
            # 
            # if(open_area1 <= 0){ # if there's no space left
            #   prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
            # } else if(new_area1 < open_area1){ # if all of them fit
            #   prop_rec <- 1 # all the new recruits can be outplanted
            # } else{ # if only some will fit, calculate what proportion will fit
            #   prop_rec <- 1-((new_area1 - open_area1)/new_area1)
            # }
            # 
            # reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
            # 
            
            # record the population size before new recruitment
            reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
            
            # add external recruits
            reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + ext_rec[i]*ext_props[ss]
            
          }
          
        } # end of iterations over each source
        
      
      
    } # end of iterations over each reef subpop
    
    
    # orchard dynamics
    for(ss in 1:s_orchard){ # for each orchard treatment
      
      # calculate total number of colonies in this orchard across all sources
      # ind_tots_ss <- rep(NA, source_orchard)
      # 
      # for(rr in 1:source_orchard){
      #   
      #   ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i-1]) # total colonies from rr^th source
      # }
      # 
      # ind_tots_s <- sum(ind_tots_ss) # total across all sources
      
      for(rr in 1:source_orchard){ # for each source of orchard recruits
        
        # get the transition matrix for this year
        T_mat <- orchard_mat_pars[[ss]][[rr]]$growth[[i]]
        
        # get the fragmentation matrix
        F_mat <- orchard_mat_pars[[ss]][[rr]]$fragmentation[[i]]
        
        # if(ind_tots_s >= rest_pars$orchard_size[ss]){ # if the orchard is full
        #   F_mat <- 0*F_mat # assume no fragments survive
        # }
        
        # get the survival probabilities for this year
        S_i <- orchard_mat_pars[[ss]][[rr]]$survival[[i]] # survival
        
        # update survival of smallest size classes with density dependence 
        # N_all <- rep(NA, source_orchard)
        # 
        # for(rrr in 1:source_orchard){
        #   N_all[rrr] <- sum(orchard_pops[[ss]][[rrr]][,i-1]) # total number of corals from rrr^th source in ss^th orchard
        # }
        # 
        # S_i[1] <- S_i[1]*exp(-dens_pars.o[[ss]][[rr]]*sum(N_all))
        # 
        
        N_mat <- orchard_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
        N_mat <- N_mat*S_i # fractions surviving to current time point
        
        # now update the population sizes:
        orchard_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1)
        
        # record this as the pre-outplant population size
        orchard_pops_pre[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i]
        
        # amount of new larvae produced at i^th time point:
        orchard_rep[[ss]][[rr]][i] <- sum(orchard_pops[[ss]][[rr]][ ,i]*orchard_mat_pars[[ss]][[rr]]$fecundity[[i]])
        
        
      } # end of iterations over each orchard source
      
      
    } # end of iterations over each orchard treatment
    
    
    # calculate total new orchard babies collected
    # holding matrix for new orchard babies from colonies originating from each source in each orchard
    new_babies.o <- matrix(NA, nrow = s_orchard, ncol = source_orchard) # rows = number of orchard treatments, col = number of sources to the orchard
    
    for(ss in 1:s_orchard){ # for each orchard
      for(rr in 1:source_orchard){ # for each source of colonies to that orchard
        # new babies collected from these colonies = new babies produced by these colonies x percent successfully collected
        new_babies.o[ss,rr] <- orchard_rep[[ss]][[rr]][i]*rest_pars$orchard_yield # orchard_yield = percent of new orchard babies successfully collected
      }
    }
    
    # calculate max possible new babies that could be collected from reference reefs this year
    new_babies.r <- ref_babies[i]*rest_pars$reef_yield
    
    #tot_babies <- sum(new_babies.o) + new_babies.r # total new babies collected from orchard and reference reefs
    
    # calculate total new babies collected from the orchards this year
    tot_new_babies.o <- sum(new_babies.o)
    
    orchard_babies[i] <- tot_new_babies.o # babies collected from the orchard
    reef_babies[i] <- new_babies.r # babies collected from reference reef
    
    # tot_babies <- tot_new_babies.o + new_babies.r # total new babies collected from orchard and reference reefs
    
    # if total new babies from orchard is less than target, collect from the reference reefs until target is reached 
    if(tot_new_babies.o < rest_pars$spawn_target){ # if target wasn't reached by orchard alone
      tot_babies <- tot_new_babies.o + min(new_babies.r, (rest_pars$spawn_target - tot_new_babies.o))
      
      # then need to track embryos collected from orchard vs. reference reef (for cost estimates)
      orchard_babies_used[i] <- tot_new_babies.o # babies used from the orchard
      reef_babies_used[i] <- min(new_babies.r, (rest_pars$spawn_target - tot_new_babies.o)) # babies used from reference reef
      
      
      
    } else{
      
      tot_babies <- tot_new_babies.o
      
      orchard_babies_used[i] <- tot_new_babies.o # babies used from the orchard
      reef_babies_used[i] <- 0 # babies used from reference reef
      
    }
    
    # make sure total per tank doesn't exceed max reasonable amount (just to make sure 10 billion don't get put in a tank and cause high dens dep mortality)
    tot_babies <- min(tot_babies, rest_pars$tank_max*rest_pars$lab_max/100) # max per tank x number of tanks (assuming 100 tiles per tank, from Fundemar's data)
    
    
    # make sure these don't exceed max lab capacity (assumed lab capacity is proportional to number of tiles)
    #tot_babies <- min(tot_babies, rest_pars$lab_max)
    
    
    if(s_lab1==0){ # if none of the lab treatments keep the recruits for a year
      
      tot_settlers0 <- tot_babies # all the babies will be outplanted this year
      tot_settlers1 <- 0 # no babies will be kept for a year
      
      # calculate total densities
     # tot_dens0 <- tot_settlers0/rest_pars$lab_max
     # tot_dens1 <- NA
      
    } else{
      
      # update tot_settlers1 based on max capacity for retaining settlers
      #tot_settlers1 <- min(tot_babies, rest_pars$lab_retain_max)
      
      # update tot_settlers1 based on proportion of tiles that can be retained for a year
      tot_settlers1 <- tot_babies*rest_pars$lab_retain_max/rest_pars$lab_max
      
      # babies that don't fit get added to the group being outplanted right away
      tot_settlers0 <- tot_babies - tot_settlers1
      
      # calculate total densities
     # tot_dens0 <- ifelse(rest_pars$lab_max > rest_pars$lab_retain_max, tot_settlers0/(rest_pars$lab_max - rest_pars$lab_retain_max), NA)
     # tot_dens1 <- tot_settlers1/rest_pars$lab_retain_max
    }
    
    
    # holding vector for settlers in each lab treatment that will be immediately outplanted
    out_settlers <- rep(0, s_lab)
    lab_tiles <- rep(NA, s_lab) # number of tiles
    
    # calculate proportion of max capacity to use this year (depends on total number of babies)
   # prop_use <- min(1, (tot_babies/14600*100)/rest_pars$lab_max) # from Fundemar's data: # min of ~ 14600 embryos per tank, 100 substrates per tank 
    prop_use <- min(1, (tot_babies/rest_pars$tank_min*100)/rest_pars$lab_max)
    
    
    # check to make sure there's no dividing by zero: at a minimum, use one tile
    if(prop_use == 0){
      prop_use <- 1 - (rest_pars$lab_max-1)/rest_pars$lab_max
    }
    
    # update number of babies used
    orchard_babies_used[i] <- prop_use*orchard_babies_used[i]
    reef_babies_used[i] <- prop_use*reef_babies_used[i]
    
    
    # put the new babies into each lab treatment and determine how many survive
    # also record number of tiles in each lab treatment
    for(ss in 1:s_lab){ # for each lab treatment
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){ # if settlers in ss^th lab treatment are outplanted immediately
        # settlers from this treatment being outplanted this year = total being outplanted this year x prop. of larvae that settle on this treatment when offered it x proportion of lab space devoted to this treatment
        out_settlers[ss] <- tot_settlers0*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]]
        
        # number of tiles
        lab_tiles[ss] <- (prop_use*(rest_pars$lab_max - rest_pars$lab_retain_max)*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]])
        
        # calculate densities on the tiles
       # dens_ss <- out_settlers[ss]/lab_tiles[ss]
        dens_ss <- ifelse(lab_tiles[ss] > 0, out_settlers[ss]/lab_tiles[ss], 0) 
        
        # update out_settlers[ss] with the fraction of these that survive to outplanting
        #out_settlers[ss] <- out_settlers[ss]*lab_pars$s0[ss]*exp(-lab_pars$m0[ss]*out_settlers[ss]) # m0 = density dependent mortality rate
        out_settlers[ss] <- out_settlers[ss]*lab_pars$s0[i, ss]*exp(-lab_pars$m0[ss]*dens_ss)
        
      }
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if settlers in ss^th lab treatment are retained for a year
        # settlers from this treatment to keep until next year = total being retained x prop. larvae that settle on this treatment x prop. of lab space devoted to this treatment
        retain_settlers <- tot_settlers1*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]]
        
        # number of tiles
        lab_tiles[ss] <- (prop_use*rest_pars$lab_retain_max*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]])
        
        # calculate densities on the tiles
        # dens_ss <- retain_settlers/lab_tiles[ss]
        dens_ss <- ifelse(lab_tiles[ss] > 0, retain_settlers/lab_tiles[ss], 0)
        
        #lab_pops[[ss]][i] <- retain_settlers*lab_pars$s1[ss]*exp(-lab_pars$m1[ss]*retain_settlers) # store survivors in the lab population
        lab_pops[[ss]][i] <- retain_settlers*lab_pars$s1[i, ss]*exp(-lab_pars$m1[ss]*dens_ss) # store survivors in the lab population
      }
      
      
      
    }
    
    # record the total number of tiles being outplanted
    tiles_out0[i] <- sum(lab_tiles[which(substr(lab_treatments, start = 1, stop = 1)=="0")])
    tiles_out1[i] <- sum(lab_tiles[which(substr(lab_treatments, start = 1, stop = 1)=="1")])
    
    tiles_out_tot[i] <- tiles_out0[i] + tiles_out1[i-1]
    
    # restoration actions: update all the population sizes based on restoration strategy
    # feedbacks on restoration actions (currently none): could mean updating the proportions of babies
    # and recruits going to different locations/treatments (lab_props, reef_prop, reef_out_props, orchard_out_props)
    
    # figure out numbers of tiles going to each orchard and lab treatment
    # steps: 
    # 1) calculate total number of tiles going to each orchard from each lab source
    # 2) determine whether there is room on the orchards, if not take the surplus and put on the reef instead
    # 3) then calculate the numbers of outplants going to reef and orchard (based on numbers of tiles, densities, and density dependent mortalities) 
    
    
    # figure out how many can go to the orchard populations
    # calculate total number of corals currently in each orchard subpopulation
    ind_tots <- rep(NA, s_orchard)
    for(ss in 1:s_orchard){
      
      ind_tots_ss <- rep(NA, source_orchard)
      
      for(rr in 1:source_orchard){
        
        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i])
      }
      
      ind_tots[ss] <- sum(ind_tots_ss)
      
      # if number of individuals in ss^th orchard is less than the number of tiles, update number of tiles to be equal to number of individuals (i.e., you remove tiles with no corals)
      if(ind_tots[ss] < orchard_tiles[[ss]][i-1]){
        orchard_tiles[[ss]][i-1] <- ind_tots[ss]#floor(ind_tots[ss])
      } #else{
        #orchard_tiles[[ss]][i-1] <- orchard_tiles[[ss]][i-1] # otherwise keep the same number of tiles
      #}
      
    }
    
    # now calculate the space in each orchard (max number of tiles that can go to each)
    orchard_space <- rep(NA, s_orchard)
    
    for(ss in 1:s_orchard){
      
      orchard_space[ss] <- max(0, rest_pars$orchard_size[ss] - orchard_tiles[[ss]][i-1]) # number of tiles ss^th orchard has space for
      
    }
    
    
    # calculate numbers of tiles that will go to each orchard and each reef from each lab source
    orchard_tiles_all <- matrix(NA, nrow = length(lab_treatments), ncol = length(orchard_treatments))
    reef_tiles_all <- matrix(NA, nrow = length(lab_treatments), ncol = length(reef_treatments))
    
    for(ss in 1:s_lab){ # for each lab treatment
      
      for(rr in 1:s_orchard){ # for each orchard
        orchard_tiles_all[ss, rr] <- lab_tiles[ss]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,rr]
      }
      
      for(rr in 1:s_reef){
        reef_tiles_all[ss, rr] <- lab_tiles[ss]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,rr]
      }
      
    }
    
    # now figure out which tiles fit in the orchards and which need to be moved to the reef
    for(rr in 1:s_orchard){ # for each orchard
      
      if(orchard_space[rr] == 0){ # if there's no space in this orchard
        # add all the orchard tiles to the first reef
        reef_tiles_all[ ,1] <- reef_tiles_all[ ,1] + orchard_tiles_all[, rr]
        orchard_tiles_all[,rr] <- orchard_tiles_all[, rr] - orchard_tiles_all[, rr]
        
        orchard_tiles[[rr]][i] <- orchard_tiles[[rr]][i-1] # number of tiles in orchard stays the same
      }
      
      if(orchard_space[rr] > 0 & sum(orchard_tiles_all[, rr]) <= orchard_space[rr]){ # if all the new tiles fit in this orchard
        # update number of tiles in orchard and don't need to modify orchard_tiles_all
        orchard_tiles[[rr]][i] <- orchard_tiles[[rr]][i-1] + sum(orchard_tiles_all[, rr])#floor(sum(orchard_tiles_all[, rr]))
      }
      
      if(orchard_space[rr] > 0 & sum(orchard_tiles_all[, rr]) > orchard_space[rr]){ # if there's some space but not enough for all

        # proportion of tiles that fit:
       # prop_fits <- orchard_space[rr]/sum(orchard_tiles_all[, rr])
        prop_fits <- ifelse(sum(orchard_tiles_all[, rr]) > 0, orchard_space[rr]/sum(orchard_tiles_all[, rr]), 0)
        
        # move the extra tiles to reef one
         reef_tiles_all[ ,rr] <- reef_tiles_all[ ,rr] + orchard_tiles_all[, rr]*(1-prop_fits)
        orchard_tiles_all[, rr] <- orchard_tiles_all[, rr]*prop_fits
       
        
        # # n_extra <- floor(sum(orchard_tiles_all[, rr]) - orchard_space[rr]) # number of extra tiles
        # for(xx in 1:n_extra){ # move extra tiles from each source to reef proportional to the number of tiles per source
        #   indx <- which(orchard_tiles_all[, rr] == max(orchard_tiles_all[, rr]))[1] # source with the most tiles
        #   orchard_tiles_all[indx, rr] <- orchard_tiles_all[indx, rr] - min(1, orchard_tiles_all[indx, rr]) # remove one tile
        #   
        #   # add this to the reef (for simplicity, add to first reef only -- "spillover reef"). indx = lab source
        #   reef_tiles_all[indx ,1] <- reef_tiles_all[indx ,1] + min(1, orchard_tiles_all[indx, rr]) 
        # 
        # }
        
        # update number of tiles in orchard
        orchard_tiles[[rr]][i] <- orchard_tiles[[rr]][i-1] + sum(orchard_tiles_all[, rr])#floor(sum(orchard_tiles_all[, rr]))
      }
      
      
    }
    
    # lab_tiles[ss]
    
    # store total number of tiles being outplanted to reefs and orchards
    reef_tiles_out[i] <- sum(as.vector(reef_tiles_all))
    orchard_tiles_out[i] <- sum(as.vector(orchard_tiles_all))
    
    
    # make a matrix with the number of recruits going from each lab treatment to each reef treatment
    reef_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # from current timestep
    reef_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # from last time step
    
    # holding vector for outplanting densities (will be used to calculate post-outplanting density dependent survival)
    dens_out <- rep(NA, s_lab)
    
    for(ss in 1:s_lab){ # for each lab treatment
      
      # calculate per tile densities to update survival with density dependence (assuming this is per tile and unaffected by total number of tiles in a location)
      # same denominator as above, just updating the numerator following any mortality that happened in the lab
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){
      
      #dens_ss <- out_settlers[ss]/lab_tiles[ss]
      dens_ss <- ifelse(lab_tiles[ss] > 0, out_settlers[ss]/lab_tiles[ss], 0)
      dens_out[ss] <- dens_ss
      
      # outplants going from ss^th lab treatment to each reef treatment
      # number of tiles x settlers per tile x prop. surviving
      reef_outplants[ss, ] <- reef_tiles_all[ss ,]*dens_ss#*exp(-dd_pars.r[,ss]*dens_ss)
      # reef_tiles_all[ss ,] = number of tiles going from ss^th lab treatment to each reef treatment
      }
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        
        # calculate per tile densities to update survival with density dependence (assuming this is per tile and unaffected by total number of tiles in a location)
        #dens_ss <- lab_pops[[ss]][i-1]/lab_tiles[ss]
        dens_ss <- ifelse(lab_tiles[ss] > 0, lab_pops[[ss]][i-1]/lab_tiles[ss], 0)
        dens_out[ss] <- dens_ss
        
        # they come from the lab population at the previous timepoint
        reef_outplants1[ss, ] <- reef_tiles_all[ss ,]*dens_ss#*exp(-dd_pars.r[,ss]*dens_ss)
      }
      
    }
    
    
    # add the outplants to the reef subpopulations
    for(ss in 1:s_reef){
      
        for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants[rr-1,ss]*exp(-dd_pars.r[,rr-1]*dens_out[rr-1])*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)
          
          # add the recruits from the previous year
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants1[rr-1,ss]*exp(-dd_pars.r[,rr-1]*dens_out[rr-1])*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
          
          # store the numbers being outplanted
          reef_out[[ss]][[rr]][i] <- reef_outplants[rr-1,ss] + reef_outplants1[rr-1,ss]
          
        }
      
    }
    
    
    # repeat for orchard outplants
    
    # orchard_space[ss] # number of tiles that will fit in ss^th orchard
    orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_orchard) # this year's
    orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_orchard) # last year's
    
    dens_out <- rep(NA, s_lab)
    
    for(ss in 1:s_lab){
      
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){
      # calculate per tile densities to update survival with density dependence (assuming this is per tile and unaffected by total number of tiles in a location)
      #dens_ss <- out_settlers[ss]/lab_tiles[ss]
      dens_ss <- ifelse(lab_tiles[ss] > 0, out_settlers[ss]/lab_tiles[ss], 0) 
      
      
      dens_out[ss] <- dens_ss
      
      orchard_outplants[ss, ] <- orchard_tiles_all[ss, ]*dens_ss#*exp(-dd_pars.o[,ss]*dens_ss)
      # 1-reef_prop[ss] = proportion lab recruits from ss lab treatment going to orchard
      # orchard_out_props[ss,] = proportion of the orchard outplants from lab treatment ss going to each orchard treatment
      }
      
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        # calculate per tile densities to update survival with density dependence (assuming this is per tile and unaffected by total number of tiles in a location)
        #dens_ss <- lab_pops[[ss]][i-1]/lab_tiles[ss]
        dens_ss <- ifelse(lab_tiles[ss] > 0, lab_pops[[ss]][i-1]/lab_tiles[ss], 0) 
        
        dens_out[ss] <- dens_ss
        
        orchard_outplants1[ss, ] <- orchard_tiles_all[ss, ]*dens_ss#*exp(-dd_pars.o[,ss]*dens_ss)
        
      }
      
    }
    
    
    # add the outplants to the orchard subpopulations
    for(ss in 1:s_orchard){
      
      for(rr in 1:source_orchard){ # for each lab source
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants[rr,ss]*exp(-dd_pars.o[,rr]*dens_out[rr])*lab_pars$size_props[rr,]
        
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants1[rr,ss]*exp(-dd_pars.o[,rr]*dens_out[rr])*lab_pars$size_props[rr,]
        
        # store the numbers being outplanted
        orchard_out[[ss]][[rr]][i] <- orchard_outplants[rr,ss] + orchard_outplants1[rr,ss]
      }
      
    }
    
    
      
    # now add any colony transplants from the orchard to the reef
    
    if(rest_pars$transplant[i]==1){ # if colonies are moved from orchard to reef this year
      
      # get the corals that will be transplanted from each size class
      #colony_mats <- list() # holding list for matrices with number of transplant colonies
      
      for(ss in 1:s_orchard){ # for each orchard subpopulation
        
        #colony_mat_ss <- list()
        
        for(rr in 1:source_orchard){ # for each lab source
          
          trans_colonies <- rest_pars$trans_mats[[ss]][[rr]][i,] # number of colonies to transplant
          
          # make sure these don't exceed the numbers in the population
          for(nn in 1:n){ # for each size class
            # if number to transplant is greater than number available at this timepoint, then only transplant the number of colonies available
            trans_colonies[nn] <- ifelse(trans_colonies[nn] > orchard_pops[[ss]][[rr]][nn ,i], orchard_pops[[ss]][[rr]][nn ,i], trans_colonies[nn])
          }
          
          # add the colonies to the correct reef population
          ss.reef <- rest_pars$trans_reef[[ss]][[rr]][i,1] # [i,1] = reef receiving the corals from the ith transplant from the ss/rr^th orchard population
          rr.reef <- rest_pars$trans_reef[[ss]][[rr]][i,2] # [i, 2] = reef source subpopulation (e.g., lab treatment 1 outplants, etc.) receiving the corals from the ith transplant from the ss/rr^th orchard population
          
         # if(prop_fits[ss.reef] !=0){ # if there's room on this reef
            reef_pops[[ss.reef]][[rr.reef]][ ,i] <-  reef_pops[[ss.reef]][[rr.reef]][ ,i] + trans_colonies
            # and substract these from the orchard
            orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] - trans_colonies
         # }
          
        } # end of iteration over all source subpopulations in ss^th orchard
        
      } # end of iteration over all orchards
      
    } # end of if statement for transplanting colonies
    
  } # end of iteration over each year
  
  # return all the population metrics
  
  
  
```
















original full function
```{r}
 # reef subpops = length(lab_treatments)*length(reef_treatments)
  # lab subpops = length(lab_treatments)

  # orchard subpopulations:
  s_orchard <- length(orchard_treatments)

  # reef subpopulations:
  s_reef <- length(reef_treatments)

  # external recruitment
  ext_rec <- Ext_fun(years, lambda, rand = ext_rand[1], seed1 = seeds[3])
  # proportions going to each reef subpop:
  ext_props <- rest_pars$reef_areas/sum(rest_pars$reef_areas)

  # lab subpopulations
  s_lab <- length(lab_treatments)
  # subpopulations that will be outplanted immediately
  #s_lab0 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "0"))
  # subpopulations that are retained in the lab for a year
  s_lab1 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "1"))
  
  # tile types
  tile_types <- rep(NA, s_lab)
  
  for(ss in 1:s_lab){
    tile_types[ss] <- substr(lab_treatments[ss], start = 3, stop = 4) # T1, T2, etc.
  }
  
  # make sure there's no duplicates:
  #tile_types = unique(tile_types)

  # sources of new recruits
  source_reef <- 1 + s_lab # number of possible sources of reef recruits (+1 is for external recruits)
  source_orchard <- s_lab # number of possible sources of orchard recruits

  # set up holding lists
  reef_pops <- list() # holding list for population sizes of each reef subpopulation
  reef_rep <- list() # holding list for total reproductive output from each reef subpopulation
  reef_mat_pars <- list() # list with data frames with the transition matrix parameters for each reef subpop

  # number of recruits outplanted to reef
  reef_out <- list()
  
  # reef population sizes before outplanting
  reef_pops_pre <- list()
  
  for(ss in 1:s_reef){

    # sublists for all the different sources of recruits to this reef
    reef_pops_ss <- list() # population sizes
    reef_rep_ss <- list() # total reproductive output
    reef_out_ss <- list() # numbers outplanted
    reef_pops_pre_ss <- list() # population sizes before outplanting
    reef_mat_pars_ss <- list() # matrix parameters

    if(reef_treatments[ss] == "none"){ # if this is the reference site

      # holding matrix for number of individuals in each size class of reference reef pop'n in each year
      reef_pops_ss[[1]] <- matrix(NA, nrow = n, ncol = years)

      # holding matrix for total reproductive output by ss^th subpop each year
      reef_rep_ss[[1]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted
      reef_out_ss[[1]] <- rep(NA, years)
      
      # reef population size before outplanting
      reef_pops_pre_ss[[1]] <- matrix(NA, nrow = n, ncol = years)

      # add initial conditions
      reef_pops_ss[[1]][,1] <- N0.r[[ss]][[1]]
      reef_pops_pre_ss[[1]][,1] <- N0.r[[ss]][[1]]

      # and get the list with the transition matrix parameters
      reef_mat_pars_ss[[1]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[1]], growth_pars.r[[ss]][[1]],
                                          shrink_pars.r[[ss]][[1]], frag_pars.r[[ss]][[1]], fec_pars.r[[ss]][[1]],
                                          sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[1]],
                                          dist_effects.r[[ss]][[1]])

    } else{

      for(rr in 1:source_reef){ # for each possible source of recruits to this reef subpop

        # holding matrix for number of individuals in each size class of the ss^th reef subpop from the rr^th source in each year
        reef_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

        # holding matrix for total reproductive output by individuals in the ss^th reef subpop from the rr^th source each year
        reef_rep_ss[[rr]] <- rep(NA, years)
        
        # holding matrix for number of recruits outplanted
        reef_out_ss[[rr]] <- rep(NA, years)
        
        # holding matrix reef population size before outplanting
        reef_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

        # add initial conditions
        reef_pops_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        reef_pops_pre_ss[[rr]][,1] <- N0.r[[ss]][[rr]]

        # and get the list with the transition matrix parameters
        reef_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[rr]], growth_pars.r[[ss]][[rr]],
                                            shrink_pars.r[[ss]][[rr]], frag_pars.r[[ss]][[rr]], fec_pars.r[[ss]][[rr]],
                                            sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[rr]],
                                            dist_effects.r[[ss]][[rr]])
        # fill in initial reproduction
        reef_rep_ss[[rr]][1] <- sum(reef_pops_ss[[rr]][,1]*reef_mat_pars_ss[[rr]]$fecundity[[1]])

      }


    }

    # put all the sublists in the outer holding lists for each reef subpop

    reef_pops[[ss]] <- reef_pops_ss
    reef_pops_pre[[ss]] <- reef_pops_pre_ss
    reef_rep[[ss]] <- reef_rep_ss
    reef_out[[ss]] <- reef_out_ss
    reef_mat_pars[[ss]] <- reef_mat_pars_ss


  }

  # repeat for orchard subpops
  orchard_pops <- list()
  orchard_pops_pre <- list()
  orchard_rep <- list()
  orchard_out <- list()
  orchard_mat_pars <- list()

  for(ss in 1:s_orchard){

    # sublists for all the different sources of recruits to the orchard
    orchard_pops_ss <- list() # population sizes
    orchard_pops_pre_ss <- list() # population sizes before outplanting
    orchard_rep_ss <- list() # total reproductive output
    orchard_out_ss <- list() # numbers outplanted
    orchard_mat_pars_ss <- list() # matrix parameters

    for(rr in 1:source_orchard){ # for each source of recruits to the ss^th orchard treatment

      # holding matrix for number of individuals in each size class of the ss^th reef subpop in each year
      orchard_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for number of individuals before outplanting
      orchard_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

      # holding matrix for total reproductive output by ss^th subpop each year
      orchard_rep_ss[[rr]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted 
      orchard_out_ss[[rr]] <- rep(NA, years)

      # add initial conditions here too
      orchard_pops_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      orchard_pops_pre_ss[[rr]][,1] <- N0.o[[ss]][[rr]]

      # and calculate the data frames with the transition matrix parameters
      orchard_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.o[[ss]][[rr]], growth_pars.o[[ss]][[rr]],
                                             shrink_pars.o[[ss]][[rr]], frag_pars.o[[ss]][[rr]],
                                             fec_pars.o[[ss]][[rr]], sigma_s, sigma_f, seeds, dist_yrs,
                                             dist_pars.o[[ss]][[rr]], dist_effects.o[[ss]][[rr]])
      # fill in initial reproduction
      orchard_rep_ss[[rr]][1] <- sum(orchard_pops_ss[[rr]][,1]*orchard_mat_pars_ss[[rr]]$fecundity[[1]])


    }


    orchard_pops[[ss]] <- orchard_pops_ss
    orchard_pops_pre[[ss]] <- orchard_pops_pre_ss
    orchard_rep[[ss]] <- orchard_rep_ss
    orchard_out[[ss]] <- orchard_out_ss
    orchard_mat_pars[[ss]] <- orchard_mat_pars_ss

  }


  # lab subpopulations
  lab_pops <- list()
  # lab_mat_pars <- list()

  for(ss in 1:s_lab){

    # holding vectors for number of individuals in the lab
    lab_pops[[ss]] <- rep(NA, years)

    # initial conditions
    lab_pops[[ss]][1] <- N0.l[[ss]]

  }



  for(i in 2:years){


    # steps:
    # 1) corals from previous year grow/die
    # 2) corals reproduce and orchard babies are collected and go to lab
    # 3) lab recruits raised from previous year (CHECK TIMELINE) and external recruits go to reef

    # restoration model: determines how many recruits/corals go in each treatment
    # and also keeps track of the costs of each treatment
    # feedback = numbers going in to each treatment depends on population sizes, env., etc.

    # reef dynamics

    # update the population size using the transition matrix:

    for(ss in 1:s_reef){ # for each reef subpopulation

      if(reef_treatments[ss] == "none"){ # if this is the reference site

        # get the transition matrix
        T_mat <- reef_mat_pars[[ss]][[1]]$growth[[i]]

        # get the fragmentation matrix
        F_mat <- reef_mat_pars[[ss]][[1]]$fragmentation[[i]]

        # if the reef is full, assume none of the fragments produced over the last year result in new colonies
        if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
          F_mat <- 0*F_mat
        }

        # get the survival probabilities
        S_i <- reef_mat_pars[[ss]][[1]]$survival[[i]] # survival

        # UPDATE survival with density dependence here
        # (QUESTION: should this depend on total reef popn or just the subpopn size?)

        N_mat <- reef_pops[[ss]][[1]][,i-1] # population sizes in each size class at last time point
        N_mat <- N_mat*S_i # fractions surviving to current time point

        # now update the population sizes
        reef_pops[[ss]][[1]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes
        
        # amount of new larvae produced at the i^th time point:
        reef_rep[[ss]][[1]][i] <- sum(reef_pops[[ss]][[1]][ ,i]*reef_mat_pars[[ss]][[1]]$fecundity[[i]])

        # add external recruits if there's room
        tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
        occupied_area1 <- sum(reef_pops[[ss]][[1]][ ,i]*A_mids) # total area currently occupied
        open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
        new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need

        if(open_area1 <= 0){ # if there's no space left
          prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
        } else if(new_area1 < open_area1){ # if all of them fit
          prop_rec <- 1 # all the new recruits can be outplanted
        } else{ # if only some will fit, calculate what proportion will fit
          prop_rec <- 1-((new_area1 - open_area1)/new_area1)
        }

        #prop_rec <- 1

        reef_pops[[ss]][[1]][1 ,i] <- reef_pops[[ss]][[1]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
        
        reef_pops_pre[[ss]][[1]][ ,i] <- reef_pops[[ss]][[1]][ ,i]
        


      } else{

        for(rr in 1:source_reef){ # for each source of recruits

          # get the transition matrix
          T_mat <- reef_mat_pars[[ss]][[rr]]$growth[[i]]

          # get the fragmentation matrix
          F_mat <- reef_mat_pars[[ss]][[rr]]$fragmentation[[i]]

          # if the reef is full, assume none of the fragments produced over the last year result in new colonies
          if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
            F_mat <- 0*F_mat
          }

          # get the survival probabilities
          S_i <- reef_mat_pars[[ss]][[rr]]$survival[[i]] # survival

          # UPDATE survival with density dependence here
          # (QUESTION: should this depend on total reef popn or just the subpopn size?)

          N_mat <- reef_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
          N_mat <- N_mat*S_i # fractions surviving to current time point

          # now update the population sizes
          reef_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes

          # record this as the pre-outplant population size
          reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          
          # amount of new larvae produced at the i^th time point:
          reef_rep[[ss]][[rr]][i] <- sum(reef_pops[[ss]][[rr]][ ,i]*reef_mat_pars[[ss]][[rr]]$fecundity[[i]])

          if(rr ==1){ # if this is the first source (external recruits)
            # add the external recruits if they fit
            tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
            occupied_area1 <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids) # total area currently occupied
            open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
            new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need

            if(open_area1 <= 0){ # if there's no space left
              prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
            } else if(new_area1 < open_area1){ # if all of them fit
              prop_rec <- 1 # all the new recruits can be outplanted
            } else{ # if only some will fit, calculate what proportion will fit
              prop_rec <- 1-((new_area1 - open_area1)/new_area1)
            }

            reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
            
            # record this as the pre-outplant population size
            reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          }

        } # end of iterations over each source

      } # end of "else" statement


    } # end of iterations over each reef subpop


    # orchard dynamics
    for(ss in 1:s_orchard){ # for each orchard treatment

      # calculate total number of colonies in this orchard
      ind_tots_ss <- rep(NA, source_orchard)

      for(rr in 1:source_orchard){

        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i-1])
      }

      ind_tots_s <- sum(ind_tots_ss)

      for(rr in 1:source_orchard){ # for each source of orchard recruits

        # get the transition matrix from the last year
        #T_mat <- orchard_mat_pars[[ss]]$growth[[i-1]]

        # get the transition matrix for this year
        T_mat <- orchard_mat_pars[[ss]][[rr]]$growth[[i]]

        # get the fragmentation matrix
        F_mat <- orchard_mat_pars[[ss]][[rr]]$fragmentation[[i]]

        if(ind_tots_s >= rest_pars$orchard_size[ss]){
          F_mat <- 0*F_mat
        }

        # get the survival probabilities for this year
        S_i <- orchard_mat_pars[[ss]][[rr]]$survival[[i]] # survival

        # UPDATE survival with density dependence here
        # (QUESTION: should this depend on total reef popn or just the subpopn size?)

        N_mat <- orchard_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point

        N_mat <- N_mat*S_i # fractions surviving to current time point

        # now update the population sizes:
        orchard_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1)
        
        # record this as the pre-outplant population size
        orchard_pops_pre[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i]

        # amount of new larvae produced since the last time point:
        #orchard_rep[[ss]][i] <- sum(N_mat[, i-1]*orchard_mat_pars[[ss]]$fecundity[[i-1]])

        # amount of new larvae produced at i^th time point:
        orchard_rep[[ss]][[rr]][i] <- sum(orchard_pops[[ss]][[rr]][ ,i]*orchard_mat_pars[[ss]][[rr]]$fecundity[[i]])


      } # end of iterations over each orchard source


    } # end of iterations over each orchard treatment


    # calculate total new orchard babies collected
    new_babies.o <- matrix(NA, nrow = s_orchard, ncol = source_orchard) # rows = number of orchard treatments, col = number of sources to the orchard

    for(ss in 1:s_orchard){
      for(rr in 1:source_orchard){
        new_babies.o[ss,rr] <- orchard_rep[[ss]][[rr]][i]*rest_pars$orchard_yield # orchard_yield = percent of new orchard babies successfully collected
      }
    }

    # calculate total new reef babies collected
    new_babies.r <- matrix(NA, nrow = s_reef, ncol = source_reef)

    for(ss in 1:s_reef){

      if(reef_treatments[ss] == "none"){ # if this is the reference reef, there is only one source
        new_babies.r[ss,1] <- reef_rep[[ss]][[1]][i]*rest_pars$reef_yield # reef_yield = percent of new reef babies successfully collected
      } else{
        for(rr in 1:source_reef){
          new_babies.r[ss,rr] <- reef_rep[[ss]][[rr]][i]*rest_pars$reef_yield
        }
      }

    }

    tot_babies <- sum(new_babies.o) + sum(new_babies.r, na.rm = T) # total new babies collected
    
    # make sure these don't exceed max lab capacity
    tot_babies <- min(tot_babies, rest_pars$lab_max)
    
    if(s_lab1==0){ # if none of the lab treatments keep the recruits for a year
      
      tot_settlers0 <- tot_babies
      tot_settlers1 <- 0
      
    } else{
      
      # determine how many can stay for a year
      tot_settlers1 <- min(tot_babies, rest_pars$lab_retain_max)
      
      # remaining babies are outplanted right away
      tot_settlers0 <- tot_babies - tot_settlers1
    }
    
    
    # need parameter for max number that the lab can handle, and then a number for the max
    # that can be retained for a year, and then have a hierarchy so everything that can be retained
    # is and any leftovers get outplanted immediately
    
    # lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
    # tile_types

    # holding vector for settlers on each lab treatment that will be immediately outplanted
    out_settlers <- rep(0, s_lab)

    # put the new babies into each lab treatment and determine how many survive
    for(ss in 1:s_lab){
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){ # if settlers in ss^th lab treatment are outplanted immediately
        out_settlers[ss] <- tot_settlers0*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
        
        # determine the fraction of these that survive to outplanting
        out_settlers[ss] <- out_settlers[ss]*lab_pars$s0[ss] # ADD density dependence here?
        
      }
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if settlers in ss^th lab treatment are retained for a year
        retain_settlers <- tot_settlers1*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
        lab_pops[[ss]][i] <- retain_settlers*lab_pars$s1[ss] # store these in the lab population
      }
      


    }


    # restoration actions: update all the population sizes based on restoration strategy
    # NOTE: any feedbacks on restoration actions would be updating the proportions of babies
    # and recruits going to different locations/treatments (lab_props, reef_prop, reef_out_props, orchard_out_props)

    # add the babies:
    # first make a matrix with the number of recruits going from each lab treatment to each reef treatment
    reef_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # from current timestep
    reef_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # from last time step

    for(ss in 1:s_lab){ # for each lab treatment

      reef_outplants[ss, ] <- out_settlers[ss]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      # reef_prop[ss] = proportion lab recruits from ss lab treatment going to reef
      # reef_out_props[ss,] = proportion of reef outplants from lab treatment ss going to treatment on reef

      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        reef_outplants1[ss, ] <- lab_pops[[ss]][i-1]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      }

    }

    # apply space constraints: total recruits from all lab treatments going to a given reef
    # treatment can't exceed available space in that reef subpopulation
    # first calculate total number of recruits (from all lab treatments) going to each reef treatment
    #new_reef_tots <- apply(reef_outplants, 2, sum)

    # calculate total area currently occupied by each reef subpopulation
    area_tots <- rep(NA, s_reef)
    for(ss in 1:s_reef){

      if(ss == 1){
        area_tots[ss] <- sum(reef_pops[[ss]][[1]][ ,i]*A_mids)
      } else{

        area_tots_ss <- rep(NA, source_reef)

        for(rr in 1:source_reef){
          area_tots_ss[rr] <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids)
        }

        area_tots[ss] <- sum(area_tots_ss)
      }

    }

    # now calculate the fractions of new recruits that can get outplanted
    prop_fits <- rep(NA, s_reef)

    for(pp in 1:s_reef){

      tot_area_pp <- rest_pars$reef_areas[pp] # total area devoted to the pp^th reef treatment
      occupied_area_pp <- area_tots[pp] # total area currently occupied

      if(occupied_area_pp >= tot_area_pp){ # if the reef subpopulation is full
        prop_fits[pp] <- 0 # no new recruits can be outplanted
      } else{ # else if there's still space
        prop_fits[pp] <- 1 # outplant the recruits
      }

      # open_area_pp <- tot_area_pp - occupied_area_pp # area that is available for new recruits
      #
      # new_area_pp <- new_reef_tots[pp]*A_mids[1] # area that the new recruit outplants will need
      #
      # if(open_area_pp <= 0){ # if there's no space left
      #   prop_fits[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      # } else if(new_area_pp < open_area_pp){ # if all of them fit
      #   prop_fits[pp] <- 1 # all the new recruits can be outplanted
      # } else{ # if only some will fit, calculate what proportion will fit
      #   prop_fits[pp] <- 1-((new_area_pp - open_area_pp)/new_area_pp)
      # }

      }

    # update outplant matrix (remember row = lab treatment where recruits originated, column = reef treatment where recruits are outplanted)
    #reef_outplants <- reef_outplants%*%matrix(prop_fits, nrow = length(reef_treatments), ncol = 1)
    for(ss in 1:s_lab){
      reef_outplants[ss,] <- reef_outplants[ss,]*prop_fits # Note: could update this to give priority to certain lab treatments?
      reef_outplants1[ss,] <- reef_outplants1[ss,]*prop_fits
    }

    # add the outplants to the reef subpopulations
    for(ss in 1:s_reef){

      if(reef_treatments[ss] != "none"){ # if this isn't a reference site (where zero outplants are added)

        for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)

          # add the recruits from the previous year
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
        
          # store the numbers being outplanted
          reef_out[[ss]][[rr]][i] <- reef_outplants[rr-1,ss] + reef_outplants1[rr-1,ss]
        
        }

      }

      # if "none" treatment also got recruits:
      # for(rr in 1:(source_reef-1)){ # for each lab source (rr = 1 is for external recruits)
      #     reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + reef_outplants[ss,rr]


    }


    # repeat for orchard outplants
    orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_orchard) # this year's
    orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_orchard) # last year's

    for(ss in 1:s_lab){

      orchard_outplants[ss, ] <- out_settlers[ss]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      # 1-reef_prop[ss] = proportion lab recruits from ss lab treatment going to orchard
      # orchard_out_props[ss,] = proportion of the orchard outplants from lab treatment ss going to each orchard treatment

      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        orchard_outplants1[ss, ] <- lab_pops[[ss]][i-1]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      }

    }

    # apply space constraints
    # calculate total number of recruits (from all lab treatments) going to each orchard treatment
    new_orchard_tots <- apply(orchard_outplants, 2, sum)

    # calculate total number of corals currently in each orchard subpopulation
    ind_tots <- rep(NA, s_orchard)
    for(ss in 1:s_orchard){

     ind_tots_ss <- rep(NA, source_orchard)

      for(rr in 1:source_orchard){

        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i])
      }

     ind_tots[ss] <- sum(ind_tots_ss)

    }


    # now calculate the fractions of new recruits that will fit in each orchard treatment
    prop_fits2 <- rep(NA, s_orchard)

    for(pp in 1:s_orchard){

      tot_ind_pp <- rest_pars$orchard_size[pp] # total number of individuals that fit in pp^th orchard treatment
      occupied_ind_pp <- ind_tots[pp] # total individuals currently in this orchard subpop

      if(occupied_ind_pp >= tot_ind_pp){ # if the orchard is full
        prop_fits2[pp] <- 0 # no new recruits can be added
      } else{ # else if there's still space
        prop_fits2[pp] <- 1 # add the new recruits
      }

      open_ind_pp <- tot_ind_pp - occupied_ind_pp # number of new recruits that could fit in the orchard subpop

      new_ind_pp <- new_orchard_tots[pp] # total number of new recruits to put in orchard

      if(open_ind_pp <= 0){ # if there's no space left
        prop_fits2[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      } else if(new_ind_pp < open_ind_pp){ # if all of them fit
        prop_fits2[pp] <- 1 # all the new recruits can be outplanted
      } else{ # if only some will fit, calculate what proportion will fit
        prop_fits2[pp] <- 1-((new_ind_pp - open_ind_pp)/new_ind_pp)
      }

    }

    # update outplant matrix (remember row = lab treatment where recruits originated, column = orchard treatment where recruits are outplanted)
   # orchard_outplants <- orchard_outplants%*%matrix(prop_fits2, nrow = length(orchard_treatments), ncol = 1)

    for(ss in 1:s_lab){ # for each lab treatment
      orchard_outplants[ss,] <- orchard_outplants[ss,]*prop_fits2
      orchard_outplants1[ss,] <- orchard_outplants1[ss,]*prop_fits2
    }
    
    # add the outplants to the orchard subpopulations
    for(ss in 1:s_orchard){
      
      for(rr in 1:source_orchard){ # for each lab source
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants[rr,ss]*lab_pars$size_props[rr,]
        
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants1[rr,ss]*lab_pars$size_props[rr,]
        
        # store the numbers being outplanted
        orchard_out[[ss]][[rr]][i] <- orchard_outplants[rr,ss] + orchard_outplants1[rr,ss]
      }
      
    }
    
    # also make a holding matrix for the recruits that didn't fit in the orchard and go to the reef instead
    # want to distribute these evenly across all intervention reefs 
    
    # if there is at least one intervention reef
    if(length(which(reef_treatments!="none")) > 0){
      
    extra_orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # this year's
    extra_orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # last year's
    
    for(ss in 1:s_lab){ # for each lab treatment
      
      extra_orchard_outplants[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants[ss,]*(1-prop_fits2))/(length(which(reef_treatments!="none"))), length(which(reef_treatments!="none"))) # this year's
      extra_orchard_outplants1[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants1[ss,]*(1-prop_fits2))/length(which(reef_treatments!="none")), length(which(reef_treatments!="none"))) # last year's
      
    }

    
    # add the extras to the reef subpopulations (if there's room on the reef)
      for(ss in 1:s_reef){
        if(prop_fits[ss] !=0){
        
        if(reef_treatments[ss] != "none"){ # if this isn't a reference site (where zero outplants are added)
          
          for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
            reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)
            
            # add the recruits from the previous year
            reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
            
            # update the numbers being outplanted
            reef_out[[ss]][[rr]][i] <- reef_out[[ss]][[rr]][i] + extra_orchard_outplants[rr-1,ss] + extra_orchard_outplants1[rr-1,ss]
          }
        }
      }
    } # end of iteration over reef subpopulations

  } # end of if(length(which(reef_treatments!="none")) > 0){

    # now add any colony transplants from the orchard to the reef

    if(rest_pars$transplant[i]==1){ # if colonies are moved from orchard to reef this year

        # get the corals that will be transplanted from each size class
        #colony_mats <- list() # holding list for matrices with number of transplant colonies

        for(ss in 1:s_orchard){ # for each orchard subpopulation

          #colony_mat_ss <- list()

          for(rr in 1:source_orchard){ # for each lab source

            trans_colonies <- rest_pars$trans_mats[[ss]][[rr]][i,]

            # make sure these don't exceed the numbers in the population
            for(nn in 1:n){ # for each size class
              # if number to transplant is greater than number available at this timepoint, then only transplant the number of colonies available
              trans_colonies[nn] <- ifelse(trans_colonies[nn] > orchard_pops[[ss]][[rr]][nn ,i], orchard_pops[[ss]][[rr]][nn ,i], trans_colonies[nn])
            }

            # add the colonies to the correct reef population
            ss.reef <- rest_pars$trans_reef[[ss]][[rr]][i,1] # [i,1] = reef area receiving the corals from the ith transplant from the ss/rr^th orchard population
            rr.reef <- rest_pars$trans_reef[[ss]][[rr]][i,2] # [i, 2] = reef source subpopulation receiving the corals from the ith transplant from the ss/rr^th orchard population

            if(prop_fits[ss.reef] !=0){ # if there's room on this reef
            reef_pops[[ss.reef]][[rr.reef]][ ,i] <-  reef_pops[[ss.reef]][[rr.reef]][ ,i] + trans_colonies
            # and substract these from the orchard
            orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] - trans_colonies
            }

          } # end of iteration over all source subpopulations in ss^th orchard

        } # end of iteration over all orchards

    } # end of if statement for transplanting colonies

  } # end of iteration over each year
  
```



```{r}
# checking subsetting characters: want to make the one-year recruits a separate lab treatment, but can overlap with other treatments so want the names to be "0_tile1" for immediate outplanting and "1_tile1" for year-old outplanting

string_test <- "1_tile1"
substr(string_test, start = 1, stop = 1)


# try a vector of strings
string_test <- c("1_tile1", "0_tile1", "1_tile2")
substr(string_test, start = 1, stop = 1)

length(which(substr(string_test, start = 1, stop = 1)=="1"))

```


connecting orchards and reefs

-- seems like you might not want to do this every year, so make this a vector where 0 means no exchange, "1" means from orchard to reef, and "2" means from reef to orchard
-- and then a matrix specifying the number you want to move from each size class? (and actual number moved would be min of that and actual number in that size class)



```{r}

transplant <- rep(0, years)
transplant[10] <- 1

trans_mat <- matrix(NA, nrow = years, ncol = n)
trans_mat[10,] <- c(0, 0, 0, 3, 0)

harvest_mat <- matrix(NA, nrow = years, ncol = n)

# trans_mat for each reef subpop, all together as a list, then harvest_mat for each orchard also all together in a list

# but also need to think about which treatment is being moved where...
# maybe just make another matrix (or list?) that specifies which orchard treatment(s) to move from and to which reef treatment(s), e.g., I want to take 5 corals from orchard 1 and put them in reef 2

# for each orchard in set of orchards to harvest, get the specified number (assume same number for all), put together into total number of colonies, then put specified numbers in each on each receiving reef. SO need to specify the number that go to each reef -- i.e., there will be trans_mats for each reef, and will need separate matrices for each orchard

```


ACTUALLY should the transplanted corals be there own subpopulation on the reef? That gets complicated...but maybe it's best to do it that way? OR just be sure to keep track of the lab origin (i.e., orchard corals from lab treatment x get put into the reef subpopulation receiving corals from lab treatment x)







