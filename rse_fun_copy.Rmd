---
title: "rse_fun_copy"
author: "Raine Detmer"
date: "2025-07-02"
output: html_document
---

README: place to copy paste the model function for debugging and to think through model additions

more simplified function without a dynamic reference reef

```{r}
 # reef subpops = length(lab_treatments)*length(reef_treatments)
  # lab subpops = length(lab_treatments)
  
  # orchard subpopulations:
  s_orchard <- length(orchard_treatments)
  
  # reef subpopulations:
  s_reef <- length(reef_treatments)
  
  # external recruitment
  ext_rec <- Ext_fun(years, lambda, rand = ext_rand[1], seed1 = seeds[3])
  # proportions going to each reef subpop:
  ext_props <- rest_pars$reef_areas/sum(rest_pars$reef_areas)
  
  # larvae from reference reef
  ref_babies <- Ext_fun(years, lambda_R, rand = ext_rand[2], seed1 = seeds[4])
  
  # lab subpopulations
  s_lab <- length(lab_treatments)
  # subpopulations that will be outplanted immediately
  #s_lab0 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "0"))
  # subpopulations that are retained in the lab for a year
  s_lab1 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "1"))
  
  # tile types
  tile_types <- rep(NA, s_lab)
  
  for(ss in 1:s_lab){
    tile_types[ss] <- substr(lab_treatments[ss], start = 3, stop = 4) # T1, T2, etc.
  }
  
  # make sure there's no duplicates:
  #tile_types = unique(tile_types)
  
  # sources of new recruits
  source_reef <- 1 + s_lab # number of possible sources of reef recruits (+1 is for external recruits)
  source_orchard <- s_lab # number of possible sources of orchard recruits
  
  # set up holding lists
  reef_pops <- list() # holding list for population sizes of each reef subpopulation
  reef_rep <- list() # holding list for total reproductive output from each reef subpopulation
  reef_mat_pars <- list() # list with data frames with the transition matrix parameters for each reef subpop
  
  # number of recruits outplanted to reef
  reef_out <- list()
  
  # reef population sizes before outplanting
  reef_pops_pre <- list()
  
  for(ss in 1:s_reef){
    
    # sublists for all the different sources of recruits to this reef
    reef_pops_ss <- list() # population sizes
    reef_rep_ss <- list() # total reproductive output
    reef_out_ss <- list() # numbers outplanted
    reef_pops_pre_ss <- list() # population sizes before outplanting
    reef_mat_pars_ss <- list() # matrix parameters
      
      for(rr in 1:source_reef){ # for each possible source of recruits to this reef subpop
        
        # holding matrix for number of individuals in each size class of the ss^th reef subpop from the rr^th source in each year
        reef_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
        
        # holding matrix for total reproductive output by individuals in the ss^th reef subpop from the rr^th source each year
        reef_rep_ss[[rr]] <- rep(NA, years)
        
        # holding matrix for number of recruits outplanted
        reef_out_ss[[rr]] <- rep(NA, years)
        
        # holding matrix reef population size before outplanting
        reef_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
        
        # add initial conditions
        reef_pops_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        reef_pops_pre_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        
        # and get the list with the transition matrix parameters
        reef_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[rr]], growth_pars.r[[ss]][[rr]],
                                               shrink_pars.r[[ss]][[rr]], frag_pars.r[[ss]][[rr]], fec_pars.r[[ss]][[rr]],
                                               sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[rr]],
                                               dist_effects.r[[ss]][[rr]])
        # fill in initial reproduction
        reef_rep_ss[[rr]][1] <- sum(reef_pops_ss[[rr]][,1]*reef_mat_pars_ss[[rr]]$fecundity[[1]])
        
      }
      
    
    # put all the sublists in the outer holding lists for each reef subpop
    
    reef_pops[[ss]] <- reef_pops_ss
    reef_pops_pre[[ss]] <- reef_pops_pre_ss
    reef_rep[[ss]] <- reef_rep_ss
    reef_out[[ss]] <- reef_out_ss
    reef_mat_pars[[ss]] <- reef_mat_pars_ss
    
    
  }
  
  # repeat for orchard subpops
  orchard_pops <- list()
  orchard_pops_pre <- list()
  orchard_rep <- list()
  orchard_out <- list()
  orchard_mat_pars <- list()
  
  for(ss in 1:s_orchard){
    
    # sublists for all the different sources of recruits to the orchard
    orchard_pops_ss <- list() # population sizes
    orchard_pops_pre_ss <- list() # population sizes before outplanting
    orchard_rep_ss <- list() # total reproductive output
    orchard_out_ss <- list() # numbers outplanted
    orchard_mat_pars_ss <- list() # matrix parameters
    
    for(rr in 1:source_orchard){ # for each source of recruits to the ss^th orchard treatment
      
      # holding matrix for number of individuals in each size class of the ss^th reef subpop in each year
      orchard_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for number of individuals before outplanting
      orchard_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for total reproductive output by ss^th subpop each year
      orchard_rep_ss[[rr]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted 
      orchard_out_ss[[rr]] <- rep(NA, years)
      
      # add initial conditions here too
      orchard_pops_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      orchard_pops_pre_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      
      # and calculate the data frames with the transition matrix parameters
      orchard_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.o[[ss]][[rr]], growth_pars.o[[ss]][[rr]],
                                                shrink_pars.o[[ss]][[rr]], frag_pars.o[[ss]][[rr]],
                                                fec_pars.o[[ss]][[rr]], sigma_s, sigma_f, seeds, dist_yrs,
                                                dist_pars.o[[ss]][[rr]], dist_effects.o[[ss]][[rr]])
      # fill in initial reproduction
      orchard_rep_ss[[rr]][1] <- sum(orchard_pops_ss[[rr]][,1]*orchard_mat_pars_ss[[rr]]$fecundity[[1]])
      
      
    }
    
    
    orchard_pops[[ss]] <- orchard_pops_ss
    orchard_pops_pre[[ss]] <- orchard_pops_pre_ss
    orchard_rep[[ss]] <- orchard_rep_ss
    orchard_out[[ss]] <- orchard_out_ss
    orchard_mat_pars[[ss]] <- orchard_mat_pars_ss
    
  }
  
  
  # lab subpopulations
  lab_pops <- list()
  # lab_mat_pars <- list()
  
  for(ss in 1:s_lab){
    
    # holding vectors for number of individuals in the lab
    lab_pops[[ss]] <- rep(NA, years)
    
    # initial conditions
    lab_pops[[ss]][1] <- N0.l[[ss]]
    
  }
  
  
  
  for(i in 2:years){
    
    
    # steps:
    # 1) corals from previous year grow/die
    # 2) corals reproduce and orchard babies are collected and go to lab
    # 3) lab recruits raised from previous year (CHECK TIMELINE) and external recruits go to reef
    
    # restoration model: determines how many recruits/corals go in each treatment
    # and also keeps track of the costs of each treatment
    # feedback = numbers going in to each treatment depends on population sizes, env., etc.
    
    # reef dynamics
    
    # update the population size using the transition matrix:
    
    for(ss in 1:s_reef){ # for each reef subpopulation
        
        for(rr in 1:source_reef){ # for each source of recruits
          
          # get the transition matrix
          T_mat <- reef_mat_pars[[ss]][[rr]]$growth[[i]]
          
          # get the fragmentation matrix
          F_mat <- reef_mat_pars[[ss]][[rr]]$fragmentation[[i]]
          
          # if the reef is full, assume none of the fragments produced over the last year result in new colonies
          if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
            F_mat <- 0*F_mat
          }
          
          # get the survival probabilities
          S_i <- reef_mat_pars[[ss]][[rr]]$survival[[i]] # survival
          
          # UPDATE survival with density dependence here
          # (QUESTION: should this depend on total reef popn or just the subpopn size?)
          
          N_mat <- reef_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
          N_mat <- N_mat*S_i # fractions surviving to current time point
          
          # now update the population sizes
          reef_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes
          
          # record this as the pre-outplant population size
          reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          
          # amount of new larvae produced at the i^th time point:
          reef_rep[[ss]][[rr]][i] <- sum(reef_pops[[ss]][[rr]][ ,i]*reef_mat_pars[[ss]][[rr]]$fecundity[[i]])
          
          if(rr ==1){ # if this is the first source (external recruits)
            # add the external recruits if they fit
            tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
            occupied_area1 <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids) # total area currently occupied
            open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
            new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need
            
            if(open_area1 <= 0){ # if there's no space left
              prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
            } else if(new_area1 < open_area1){ # if all of them fit
              prop_rec <- 1 # all the new recruits can be outplanted
            } else{ # if only some will fit, calculate what proportion will fit
              prop_rec <- 1-((new_area1 - open_area1)/new_area1)
            }
            
            reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
            
            # record this as the pre-outplant population size
            reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          }
          
        } # end of iterations over each source
        
      
      
    } # end of iterations over each reef subpop
    
    
    # orchard dynamics
    for(ss in 1:s_orchard){ # for each orchard treatment
      
      # calculate total number of colonies in this orchard
      ind_tots_ss <- rep(NA, source_orchard)
      
      for(rr in 1:source_orchard){
        
        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i-1])
      }
      
      ind_tots_s <- sum(ind_tots_ss)
      
      for(rr in 1:source_orchard){ # for each source of orchard recruits
        
        # get the transition matrix from the last year
        #T_mat <- orchard_mat_pars[[ss]]$growth[[i-1]]
        
        # get the transition matrix for this year
        T_mat <- orchard_mat_pars[[ss]][[rr]]$growth[[i]]
        
        # get the fragmentation matrix
        F_mat <- orchard_mat_pars[[ss]][[rr]]$fragmentation[[i]]
        
        if(ind_tots_s >= rest_pars$orchard_size[ss]){
          F_mat <- 0*F_mat
        }
        
        # get the survival probabilities for this year
        S_i <- orchard_mat_pars[[ss]][[rr]]$survival[[i]] # survival
        
        # UPDATE survival with density dependence here
        # (QUESTION: should this depend on total reef popn or just the subpopn size?)
        
        N_mat <- orchard_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
        
        N_mat <- N_mat*S_i # fractions surviving to current time point
        
        # now update the population sizes:
        orchard_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1)
        
        # record this as the pre-outplant population size
        orchard_pops_pre[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i]
        
        # amount of new larvae produced since the last time point:
        #orchard_rep[[ss]][i] <- sum(N_mat[, i-1]*orchard_mat_pars[[ss]]$fecundity[[i-1]])
        
        # amount of new larvae produced at i^th time point:
        orchard_rep[[ss]][[rr]][i] <- sum(orchard_pops[[ss]][[rr]][ ,i]*orchard_mat_pars[[ss]][[rr]]$fecundity[[i]])
        
        
      } # end of iterations over each orchard source
      
      
    } # end of iterations over each orchard treatment
    
    
    # calculate total new orchard babies collected
    new_babies.o <- matrix(NA, nrow = s_orchard, ncol = source_orchard) # rows = number of orchard treatments, col = number of sources to the orchard
    
    for(ss in 1:s_orchard){
      for(rr in 1:source_orchard){
        new_babies.o[ss,rr] <- orchard_rep[[ss]][[rr]][i]*rest_pars$orchard_yield # orchard_yield = percent of new orchard babies successfully collected
      }
    }
    
    # calculate total new babies collected from reference reefs
    new_babies.r <- ref_babies*rest_pars$reef_yield
    
    tot_babies <- sum(new_babies.o) + new_babies.r # total new babies collected
    
    # make sure these don't exceed max lab capacity
    tot_babies <- min(tot_babies, rest_pars$lab_max)
    
    if(s_lab1==0){ # if none of the lab treatments keep the recruits for a year
      
      tot_settlers0 <- tot_babies
      tot_settlers1 <- 0
      
    } else{
      
      # determine how many can stay for a year
      tot_settlers1 <- min(tot_babies, rest_pars$lab_retain_max)
      
      # remaining babies are outplanted right away
      tot_settlers0 <- tot_babies - tot_settlers1
    }
    
    
    # need parameter for max number that the lab can handle, and then a number for the max
    # that can be retained for a year, and then have a hierarchy so everything that can be retained
    # is and any leftovers get outplanted immediately
    
    # lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
    # tile_types
    
    # holding vector for settlers on each lab treatment that will be immediately outplanted
    out_settlers <- rep(0, s_lab)
    
    # put the new babies into each lab treatment and determine how many survive
    for(ss in 1:s_lab){
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){ # if settlers in ss^th lab treatment are outplanted immediately
        out_settlers[ss] <- tot_settlers0*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]]
        
        # determine the fraction of these that survive to outplanting
        out_settlers[ss] <- out_settlers[ss]*lab_pars$s0[ss] # ADD density dependence here?
        
      }
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if settlers in ss^th lab treatment are retained for a year
        retain_settlers <- tot_settlers1*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]*rest_pars$tile_props[[which(names(rest_pars$tile_props)==tile_types[ss])]]
        lab_pops[[ss]][i] <- retain_settlers*lab_pars$s1[ss] # store these in the lab population
      }
      
      
      
    }
    
    
    # restoration actions: update all the population sizes based on restoration strategy
    # NOTE: any feedbacks on restoration actions would be updating the proportions of babies
    # and recruits going to different locations/treatments (lab_props, reef_prop, reef_out_props, orchard_out_props)
    
    # add the babies:
    # first make a matrix with the number of recruits going from each lab treatment to each reef treatment
    reef_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # from current timestep
    reef_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # from last time step
    
    for(ss in 1:s_lab){ # for each lab treatment
      
      reef_outplants[ss, ] <- out_settlers[ss]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      # reef_prop[ss] = proportion lab recruits from ss lab treatment going to reef
      # reef_out_props[ss,] = proportion of reef outplants from lab treatment ss going to treatment on reef
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        reef_outplants1[ss, ] <- lab_pops[[ss]][i-1]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      }
      
    }
    
    # apply space constraints: total recruits from all lab treatments going to a given reef
    # treatment can't exceed available space in that reef subpopulation
    # first calculate total number of recruits (from all lab treatments) going to each reef treatment
    #new_reef_tots <- apply(reef_outplants, 2, sum)
    
    # calculate total area currently occupied by each reef subpopulation
    area_tots <- rep(NA, s_reef)
    for(ss in 1:s_reef){
      
      if(ss == 1){
        area_tots[ss] <- sum(reef_pops[[ss]][[1]][ ,i]*A_mids)
      } else{
        
        area_tots_ss <- rep(NA, source_reef)
        
        for(rr in 1:source_reef){
          area_tots_ss[rr] <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids)
        }
        
        area_tots[ss] <- sum(area_tots_ss)
      }
      
    }
    
    # now calculate the fractions of new recruits that can get outplanted
    prop_fits <- rep(NA, s_reef)
    
    for(pp in 1:s_reef){
      
      tot_area_pp <- rest_pars$reef_areas[pp] # total area devoted to the pp^th reef treatment
      occupied_area_pp <- area_tots[pp] # total area currently occupied
      
      if(occupied_area_pp >= tot_area_pp){ # if the reef subpopulation is full
        prop_fits[pp] <- 0 # no new recruits can be outplanted
      } else{ # else if there's still space
        prop_fits[pp] <- 1 # outplant the recruits
      }
      
      # open_area_pp <- tot_area_pp - occupied_area_pp # area that is available for new recruits
      #
      # new_area_pp <- new_reef_tots[pp]*A_mids[1] # area that the new recruit outplants will need
      #
      # if(open_area_pp <= 0){ # if there's no space left
      #   prop_fits[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      # } else if(new_area_pp < open_area_pp){ # if all of them fit
      #   prop_fits[pp] <- 1 # all the new recruits can be outplanted
      # } else{ # if only some will fit, calculate what proportion will fit
      #   prop_fits[pp] <- 1-((new_area_pp - open_area_pp)/new_area_pp)
      # }
      
    }
    
    # update outplant matrix (remember row = lab treatment where recruits originated, column = reef treatment where recruits are outplanted)
    #reef_outplants <- reef_outplants%*%matrix(prop_fits, nrow = length(reef_treatments), ncol = 1)
    for(ss in 1:s_lab){
      reef_outplants[ss,] <- reef_outplants[ss,]*prop_fits # Note: could update this to give priority to certain lab treatments?
      reef_outplants1[ss,] <- reef_outplants1[ss,]*prop_fits
    }
    
    # add the outplants to the reef subpopulations
    for(ss in 1:s_reef){
      
        for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)
          
          # add the recruits from the previous year
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
          
          # store the numbers being outplanted
          reef_out[[ss]][[rr]][i] <- reef_outplants[rr-1,ss] + reef_outplants1[rr-1,ss]
          
        }
      
    }
    
    
    # repeat for orchard outplants
    orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_orchard) # this year's
    orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_orchard) # last year's
    
    for(ss in 1:s_lab){
      
      orchard_outplants[ss, ] <- out_settlers[ss]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      # 1-reef_prop[ss] = proportion lab recruits from ss lab treatment going to orchard
      # orchard_out_props[ss,] = proportion of the orchard outplants from lab treatment ss going to each orchard treatment
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        orchard_outplants1[ss, ] <- lab_pops[[ss]][i-1]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      }
      
    }
    
    # apply space constraints
    # calculate total number of recruits (from all lab treatments) going to each orchard treatment
    new_orchard_tots <- apply(orchard_outplants, 2, sum)
    
    # calculate total number of corals currently in each orchard subpopulation
    ind_tots <- rep(NA, s_orchard)
    for(ss in 1:s_orchard){
      
      ind_tots_ss <- rep(NA, source_orchard)
      
      for(rr in 1:source_orchard){
        
        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i])
      }
      
      ind_tots[ss] <- sum(ind_tots_ss)
      
    }
    
    
    # now calculate the fractions of new recruits that will fit in each orchard treatment
    prop_fits2 <- rep(NA, s_orchard)
    
    for(pp in 1:s_orchard){
      
      tot_ind_pp <- rest_pars$orchard_size[pp] # total number of individuals that fit in pp^th orchard treatment
      occupied_ind_pp <- ind_tots[pp] # total individuals currently in this orchard subpop
      
      if(occupied_ind_pp >= tot_ind_pp){ # if the orchard is full
        prop_fits2[pp] <- 0 # no new recruits can be added
      } else{ # else if there's still space
        prop_fits2[pp] <- 1 # add the new recruits
      }
      
      open_ind_pp <- tot_ind_pp - occupied_ind_pp # number of new recruits that could fit in the orchard subpop
      
      new_ind_pp <- new_orchard_tots[pp] # total number of new recruits to put in orchard
      
      if(open_ind_pp <= 0){ # if there's no space left
        prop_fits2[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      } else if(new_ind_pp < open_ind_pp){ # if all of them fit
        prop_fits2[pp] <- 1 # all the new recruits can be outplanted
      } else{ # if only some will fit, calculate what proportion will fit
        prop_fits2[pp] <- 1-((new_ind_pp - open_ind_pp)/new_ind_pp)
      }
      
    }
    
    # update outplant matrix (remember row = lab treatment where recruits originated, column = orchard treatment where recruits are outplanted)
    # orchard_outplants <- orchard_outplants%*%matrix(prop_fits2, nrow = length(orchard_treatments), ncol = 1)
    
    for(ss in 1:s_lab){ # for each lab treatment
      orchard_outplants[ss,] <- orchard_outplants[ss,]*prop_fits2
      orchard_outplants1[ss,] <- orchard_outplants1[ss,]*prop_fits2
    }
    
    # add the outplants to the orchard subpopulations
    for(ss in 1:s_orchard){
      
      for(rr in 1:source_orchard){ # for each lab source
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants[rr,ss]*lab_pars$size_props[rr,]
        
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants1[rr,ss]*lab_pars$size_props[rr,]
        
        # store the numbers being outplanted
        orchard_out[[ss]][[rr]][i] <- orchard_outplants[rr,ss] + orchard_outplants1[rr,ss]
      }
      
    }
    
    # also make a holding matrix for the recruits that didn't fit in the orchard and go to the reef instead
    # want to distribute these evenly across all intervention reefs 
      
      extra_orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # this year's
      extra_orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # last year's
      
      for(ss in 1:s_lab){ # for each lab treatment
        
        extra_orchard_outplants[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants[ss,]*(1-prop_fits2))/(length(which(reef_treatments!="none"))), length(which(reef_treatments!="none"))) # this year's
        extra_orchard_outplants1[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants1[ss,]*(1-prop_fits2))/length(which(reef_treatments!="none")), length(which(reef_treatments!="none"))) # last year's
        
      }
      
      
      # add the extras to the reef subpopulations (if there's room on the reef)
      for(ss in 1:s_reef){
        if(prop_fits[ss] !=0){
          
            for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
              reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)
              
              # add the recruits from the previous year
              reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
              
              # update the numbers being outplanted
              reef_out[[ss]][[rr]][i] <- reef_out[[ss]][[rr]][i] + extra_orchard_outplants[rr-1,ss] + extra_orchard_outplants1[rr-1,ss]
            }
          
        }
      } # end of iteration over reef subpopulations
      
    
    # now add any colony transplants from the orchard to the reef
    
    if(rest_pars$transplant[i]==1){ # if colonies are moved from orchard to reef this year
      
      # get the corals that will be transplanted from each size class
      #colony_mats <- list() # holding list for matrices with number of transplant colonies
      
      for(ss in 1:s_orchard){ # for each orchard subpopulation
        
        #colony_mat_ss <- list()
        
        for(rr in 1:source_orchard){ # for each lab source
          
          trans_colonies <- rest_pars$trans_mats[[ss]][[rr]][i,]
          
          # make sure these don't exceed the numbers in the population
          for(nn in 1:n){ # for each size class
            # if number to transplant is greater than number available at this timepoint, then only transplant the number of colonies available
            trans_colonies[nn] <- ifelse(trans_colonies[nn] > orchard_pops[[ss]][[rr]][nn ,i], orchard_pops[[ss]][[rr]][nn ,i], trans_colonies[nn])
          }
          
          # add the colonies to the correct reef population
          ss.reef <- rest_pars$trans_reef[[ss]][[rr]][i,1] # [i,1] = reef receiving the corals from the ith transplant from the ss/rr^th orchard population
          rr.reef <- rest_pars$trans_reef[[ss]][[rr]][i,2] # [i, 2] = reef source subpopulation (e.g., lab treatment 1 outplants, etc.) receiving the corals from the ith transplant from the ss/rr^th orchard population
          
          if(prop_fits[ss.reef] !=0){ # if there's room on this reef
            reef_pops[[ss.reef]][[rr.reef]][ ,i] <-  reef_pops[[ss.reef]][[rr.reef]][ ,i] + trans_colonies
            # and substract these from the orchard
            orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] - trans_colonies
          }
          
        } # end of iteration over all source subpopulations in ss^th orchard
        
      } # end of iteration over all orchards
      
    } # end of if statement for transplanting colonies
    
  } # end of iteration over each year
```



original full function
```{r}
 # reef subpops = length(lab_treatments)*length(reef_treatments)
  # lab subpops = length(lab_treatments)

  # orchard subpopulations:
  s_orchard <- length(orchard_treatments)

  # reef subpopulations:
  s_reef <- length(reef_treatments)

  # external recruitment
  ext_rec <- Ext_fun(years, lambda, rand = ext_rand, seed1 = seeds[3])
  # proportions going to each reef subpop:
  ext_props <- rest_pars$reef_areas/sum(rest_pars$reef_areas)

  # lab subpopulations
  s_lab <- length(lab_treatments)
  # subpopulations that will be outplanted immediately
  #s_lab0 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "0"))
  # subpopulations that are retained in the lab for a year
  s_lab1 <- length(which(substr(lab_treatments, start = 1, stop = 1) == "1"))
  
  # tile types
  tile_types <- rep(NA, s_lab)
  
  for(ss in 1:s_lab){
    tile_types[ss] <- substr(lab_treatments[ss], start = 3, stop = 4) # T1, T2, etc.
  }
  
  # make sure there's no duplicates:
  #tile_types = unique(tile_types)

  # sources of new recruits
  source_reef <- 1 + s_lab # number of possible sources of reef recruits (+1 is for external recruits)
  source_orchard <- s_lab # number of possible sources of orchard recruits

  # set up holding lists
  reef_pops <- list() # holding list for population sizes of each reef subpopulation
  reef_rep <- list() # holding list for total reproductive output from each reef subpopulation
  reef_mat_pars <- list() # list with data frames with the transition matrix parameters for each reef subpop

  # number of recruits outplanted to reef
  reef_out <- list()
  
  # reef population sizes before outplanting
  reef_pops_pre <- list()
  
  for(ss in 1:s_reef){

    # sublists for all the different sources of recruits to this reef
    reef_pops_ss <- list() # population sizes
    reef_rep_ss <- list() # total reproductive output
    reef_out_ss <- list() # numbers outplanted
    reef_pops_pre_ss <- list() # population sizes before outplanting
    reef_mat_pars_ss <- list() # matrix parameters

    if(reef_treatments[ss] == "none"){ # if this is the reference site

      # holding matrix for number of individuals in each size class of reference reef pop'n in each year
      reef_pops_ss[[1]] <- matrix(NA, nrow = n, ncol = years)

      # holding matrix for total reproductive output by ss^th subpop each year
      reef_rep_ss[[1]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted
      reef_out_ss[[1]] <- rep(NA, years)
      
      # reef population size before outplanting
      reef_pops_pre_ss[[1]] <- matrix(NA, nrow = n, ncol = years)

      # add initial conditions
      reef_pops_ss[[1]][,1] <- N0.r[[ss]][[1]]
      reef_pops_pre_ss[[1]][,1] <- N0.r[[ss]][[1]]

      # and get the list with the transition matrix parameters
      reef_mat_pars_ss[[1]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[1]], growth_pars.r[[ss]][[1]],
                                          shrink_pars.r[[ss]][[1]], frag_pars.r[[ss]][[1]], fec_pars.r[[ss]][[1]],
                                          sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[1]],
                                          dist_effects.r[[ss]][[1]])

    } else{

      for(rr in 1:source_reef){ # for each possible source of recruits to this reef subpop

        # holding matrix for number of individuals in each size class of the ss^th reef subpop from the rr^th source in each year
        reef_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

        # holding matrix for total reproductive output by individuals in the ss^th reef subpop from the rr^th source each year
        reef_rep_ss[[rr]] <- rep(NA, years)
        
        # holding matrix for number of recruits outplanted
        reef_out_ss[[rr]] <- rep(NA, years)
        
        # holding matrix reef population size before outplanting
        reef_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

        # add initial conditions
        reef_pops_ss[[rr]][,1] <- N0.r[[ss]][[rr]]
        reef_pops_pre_ss[[rr]][,1] <- N0.r[[ss]][[rr]]

        # and get the list with the transition matrix parameters
        reef_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.r[[ss]][[rr]], growth_pars.r[[ss]][[rr]],
                                            shrink_pars.r[[ss]][[rr]], frag_pars.r[[ss]][[rr]], fec_pars.r[[ss]][[rr]],
                                            sigma_s, sigma_f, seeds, dist_yrs, dist_pars.r[[ss]][[rr]],
                                            dist_effects.r[[ss]][[rr]])
        # fill in initial reproduction
        reef_rep_ss[[rr]][1] <- sum(reef_pops_ss[[rr]][,1]*reef_mat_pars_ss[[rr]]$fecundity[[1]])

      }


    }

    # put all the sublists in the outer holding lists for each reef subpop

    reef_pops[[ss]] <- reef_pops_ss
    reef_pops_pre[[ss]] <- reef_pops_pre_ss
    reef_rep[[ss]] <- reef_rep_ss
    reef_out[[ss]] <- reef_out_ss
    reef_mat_pars[[ss]] <- reef_mat_pars_ss


  }

  # repeat for orchard subpops
  orchard_pops <- list()
  orchard_pops_pre <- list()
  orchard_rep <- list()
  orchard_out <- list()
  orchard_mat_pars <- list()

  for(ss in 1:s_orchard){

    # sublists for all the different sources of recruits to the orchard
    orchard_pops_ss <- list() # population sizes
    orchard_pops_pre_ss <- list() # population sizes before outplanting
    orchard_rep_ss <- list() # total reproductive output
    orchard_out_ss <- list() # numbers outplanted
    orchard_mat_pars_ss <- list() # matrix parameters

    for(rr in 1:source_orchard){ # for each source of recruits to the ss^th orchard treatment

      # holding matrix for number of individuals in each size class of the ss^th reef subpop in each year
      orchard_pops_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)
      
      # holding matrix for number of individuals before outplanting
      orchard_pops_pre_ss[[rr]] <- matrix(NA, nrow = n, ncol = years)

      # holding matrix for total reproductive output by ss^th subpop each year
      orchard_rep_ss[[rr]] <- rep(NA, years)
      
      # holding matrix for number of recruits outplanted 
      orchard_out_ss[[rr]] <- rep(NA, years)

      # add initial conditions here too
      orchard_pops_ss[[rr]][,1] <- N0.o[[ss]][[rr]]
      orchard_pops_pre_ss[[rr]][,1] <- N0.o[[ss]][[rr]]

      # and calculate the data frames with the transition matrix parameters
      orchard_mat_pars_ss[[rr]] <- mat_pars_fun(years, n, surv_pars.o[[ss]][[rr]], growth_pars.o[[ss]][[rr]],
                                             shrink_pars.o[[ss]][[rr]], frag_pars.o[[ss]][[rr]],
                                             fec_pars.o[[ss]][[rr]], sigma_s, sigma_f, seeds, dist_yrs,
                                             dist_pars.o[[ss]][[rr]], dist_effects.o[[ss]][[rr]])
      # fill in initial reproduction
      orchard_rep_ss[[rr]][1] <- sum(orchard_pops_ss[[rr]][,1]*orchard_mat_pars_ss[[rr]]$fecundity[[1]])


    }


    orchard_pops[[ss]] <- orchard_pops_ss
    orchard_pops_pre[[ss]] <- orchard_pops_pre_ss
    orchard_rep[[ss]] <- orchard_rep_ss
    orchard_out[[ss]] <- orchard_out_ss
    orchard_mat_pars[[ss]] <- orchard_mat_pars_ss

  }


  # lab subpopulations
  lab_pops <- list()
  # lab_mat_pars <- list()

  for(ss in 1:s_lab){

    # holding vectors for number of individuals in the lab
    lab_pops[[ss]] <- rep(NA, years)

    # initial conditions
    lab_pops[[ss]][1] <- N0.l[[ss]]

  }



  for(i in 2:years){


    # steps:
    # 1) corals from previous year grow/die
    # 2) corals reproduce and orchard babies are collected and go to lab
    # 3) lab recruits raised from previous year (CHECK TIMELINE) and external recruits go to reef

    # restoration model: determines how many recruits/corals go in each treatment
    # and also keeps track of the costs of each treatment
    # feedback = numbers going in to each treatment depends on population sizes, env., etc.

    # reef dynamics

    # update the population size using the transition matrix:

    for(ss in 1:s_reef){ # for each reef subpopulation

      if(reef_treatments[ss] == "none"){ # if this is the reference site

        # get the transition matrix
        T_mat <- reef_mat_pars[[ss]][[1]]$growth[[i]]

        # get the fragmentation matrix
        F_mat <- reef_mat_pars[[ss]][[1]]$fragmentation[[i]]

        # if the reef is full, assume none of the fragments produced over the last year result in new colonies
        if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
          F_mat <- 0*F_mat
        }

        # get the survival probabilities
        S_i <- reef_mat_pars[[ss]][[1]]$survival[[i]] # survival

        # UPDATE survival with density dependence here
        # (QUESTION: should this depend on total reef popn or just the subpopn size?)

        N_mat <- reef_pops[[ss]][[1]][,i-1] # population sizes in each size class at last time point
        N_mat <- N_mat*S_i # fractions surviving to current time point

        # now update the population sizes
        reef_pops[[ss]][[1]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes
        
        # amount of new larvae produced at the i^th time point:
        reef_rep[[ss]][[1]][i] <- sum(reef_pops[[ss]][[1]][ ,i]*reef_mat_pars[[ss]][[1]]$fecundity[[i]])

        # add external recruits if there's room
        tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
        occupied_area1 <- sum(reef_pops[[ss]][[1]][ ,i]*A_mids) # total area currently occupied
        open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
        new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need

        if(open_area1 <= 0){ # if there's no space left
          prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
        } else if(new_area1 < open_area1){ # if all of them fit
          prop_rec <- 1 # all the new recruits can be outplanted
        } else{ # if only some will fit, calculate what proportion will fit
          prop_rec <- 1-((new_area1 - open_area1)/new_area1)
        }

        #prop_rec <- 1

        reef_pops[[ss]][[1]][1 ,i] <- reef_pops[[ss]][[1]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
        
        reef_pops_pre[[ss]][[1]][ ,i] <- reef_pops[[ss]][[1]][ ,i]
        


      } else{

        for(rr in 1:source_reef){ # for each source of recruits

          # get the transition matrix
          T_mat <- reef_mat_pars[[ss]][[rr]]$growth[[i]]

          # get the fragmentation matrix
          F_mat <- reef_mat_pars[[ss]][[rr]]$fragmentation[[i]]

          # if the reef is full, assume none of the fragments produced over the last year result in new colonies
          if(sum(reef_pops[[ss]][[1]][ ,i-1]*A_mids) >= rest_pars$reef_areas[ss]){
            F_mat <- 0*F_mat
          }

          # get the survival probabilities
          S_i <- reef_mat_pars[[ss]][[rr]]$survival[[i]] # survival

          # UPDATE survival with density dependence here
          # (QUESTION: should this depend on total reef popn or just the subpopn size?)

          N_mat <- reef_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point
          N_mat <- N_mat*S_i # fractions surviving to current time point

          # now update the population sizes
          reef_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1) # new population sizes

          # record this as the pre-outplant population size
          reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          
          # amount of new larvae produced at the i^th time point:
          reef_rep[[ss]][[rr]][i] <- sum(reef_pops[[ss]][[rr]][ ,i]*reef_mat_pars[[ss]][[rr]]$fecundity[[i]])

          if(rr ==1){ # if this is the first source (external recruits)
            # add the external recruits if they fit
            tot_area1 <- rest_pars$reef_areas[ss] # total area devoted to the ss^th reef treatment
            occupied_area1 <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids) # total area currently occupied
            open_area1 <- tot_area1 - occupied_area1 # area that is available for new recruits
            new_area1 <- ext_rec[i]*ext_props[ss]*A_mids[1] # area that the new recruits will need

            if(open_area1 <= 0){ # if there's no space left
              prop_rec <- 0 # proportion of new recruits that can be outplanted is 0
            } else if(new_area1 < open_area1){ # if all of them fit
              prop_rec <- 1 # all the new recruits can be outplanted
            } else{ # if only some will fit, calculate what proportion will fit
              prop_rec <- 1-((new_area1 - open_area1)/new_area1)
            }

            reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + ext_rec[i]*ext_props[ss]*prop_rec
            
            # record this as the pre-outplant population size
            reef_pops_pre[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i]
          }

        } # end of iterations over each source

      } # end of "else" statement


    } # end of iterations over each reef subpop


    # orchard dynamics
    for(ss in 1:s_orchard){ # for each orchard treatment

      # calculate total number of colonies in this orchard
      ind_tots_ss <- rep(NA, source_orchard)

      for(rr in 1:source_orchard){

        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i-1])
      }

      ind_tots_s <- sum(ind_tots_ss)

      for(rr in 1:source_orchard){ # for each source of orchard recruits

        # get the transition matrix from the last year
        #T_mat <- orchard_mat_pars[[ss]]$growth[[i-1]]

        # get the transition matrix for this year
        T_mat <- orchard_mat_pars[[ss]][[rr]]$growth[[i]]

        # get the fragmentation matrix
        F_mat <- orchard_mat_pars[[ss]][[rr]]$fragmentation[[i]]

        if(ind_tots_s >= rest_pars$orchard_size[ss]){
          F_mat <- 0*F_mat
        }

        # get the survival probabilities for this year
        S_i <- orchard_mat_pars[[ss]][[rr]]$survival[[i]] # survival

        # UPDATE survival with density dependence here
        # (QUESTION: should this depend on total reef popn or just the subpopn size?)

        N_mat <- orchard_pops[[ss]][[rr]][,i-1] # population sizes in each size class at last time point

        N_mat <- N_mat*S_i # fractions surviving to current time point

        # now update the population sizes:
        orchard_pops[[ss]][[rr]][ ,i] <- (T_mat + F_mat) %*% matrix(N_mat, nrow = n, ncol = 1)
        
        # record this as the pre-outplant population size
        orchard_pops_pre[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i]

        # amount of new larvae produced since the last time point:
        #orchard_rep[[ss]][i] <- sum(N_mat[, i-1]*orchard_mat_pars[[ss]]$fecundity[[i-1]])

        # amount of new larvae produced at i^th time point:
        orchard_rep[[ss]][[rr]][i] <- sum(orchard_pops[[ss]][[rr]][ ,i]*orchard_mat_pars[[ss]][[rr]]$fecundity[[i]])


      } # end of iterations over each orchard source


    } # end of iterations over each orchard treatment


    # calculate total new orchard babies collected
    new_babies.o <- matrix(NA, nrow = s_orchard, ncol = source_orchard) # rows = number of orchard treatments, col = number of sources to the orchard

    for(ss in 1:s_orchard){
      for(rr in 1:source_orchard){
        new_babies.o[ss,rr] <- orchard_rep[[ss]][[rr]][i]*rest_pars$orchard_yield # orchard_yield = percent of new orchard babies successfully collected
      }
    }

    # calculate total new reef babies collected
    new_babies.r <- matrix(NA, nrow = s_reef, ncol = source_reef)

    for(ss in 1:s_reef){

      if(reef_treatments[ss] == "none"){ # if this is the reference reef, there is only one source
        new_babies.r[ss,1] <- reef_rep[[ss]][[1]][i]*rest_pars$reef_yield # reef_yield = percent of new reef babies successfully collected
      } else{
        for(rr in 1:source_reef){
          new_babies.r[ss,rr] <- reef_rep[[ss]][[rr]][i]*rest_pars$reef_yield
        }
      }

    }

    tot_babies <- sum(new_babies.o) + sum(new_babies.r, na.rm = T) # total new babies collected
    
    # make sure these don't exceed max lab capacity
    tot_babies <- min(tot_babies, rest_pars$lab_max)
    
    if(s_lab1==0){ # if none of the lab treatments keep the recruits for a year
      
      tot_settlers0 <- tot_babies
      tot_settlers1 <- 0
      
    } else{
      
      # determine how many can stay for a year
      tot_settlers1 <- min(tot_babies, rest_pars$lab_retain_max)
      
      # remaining babies are outplanted right away
      tot_settlers0 <- tot_babies - tot_settlers1
    }
    
    
    # need parameter for max number that the lab can handle, and then a number for the max
    # that can be retained for a year, and then have a hierarchy so everything that can be retained
    # is and any leftovers get outplanted immediately
    
    # lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
    # tile_types

    # holding vector for settlers on each lab treatment that will be immediately outplanted
    out_settlers <- rep(0, s_lab)

    # put the new babies into each lab treatment and determine how many survive
    for(ss in 1:s_lab){
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="0"){ # if settlers in ss^th lab treatment are outplanted immediately
        out_settlers[ss] <- tot_settlers0*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
        
        # determine the fraction of these that survive to outplanting
        out_settlers[ss] <- out_settlers[ss]*lab_pars$s0[ss] # ADD density dependence here?
        
      }
      
      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if settlers in ss^th lab treatment are retained for a year
        retain_settlers <- tot_settlers1*lab_pars$sett_props[[which(names(lab_pars$sett_props)==tile_types[ss])]]
        lab_pops[[ss]][i] <- retain_settlers*lab_pars$s1[ss] # store these in the lab population
      }
      


    }


    # restoration actions: update all the population sizes based on restoration strategy
    # NOTE: any feedbacks on restoration actions would be updating the proportions of babies
    # and recruits going to different locations/treatments (lab_props, reef_prop, reef_out_props, orchard_out_props)

    # add the babies:
    # first make a matrix with the number of recruits going from each lab treatment to each reef treatment
    reef_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # from current timestep
    reef_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # from last time step

    for(ss in 1:s_lab){ # for each lab treatment

      reef_outplants[ss, ] <- out_settlers[ss]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      # reef_prop[ss] = proportion lab recruits from ss lab treatment going to reef
      # reef_out_props[ss,] = proportion of reef outplants from lab treatment ss going to treatment on reef

      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        reef_outplants1[ss, ] <- lab_pops[[ss]][i-1]*rest_pars$reef_prop[ss]*rest_pars$reef_out_props[ss,]
      }

    }

    # apply space constraints: total recruits from all lab treatments going to a given reef
    # treatment can't exceed available space in that reef subpopulation
    # first calculate total number of recruits (from all lab treatments) going to each reef treatment
    #new_reef_tots <- apply(reef_outplants, 2, sum)

    # calculate total area currently occupied by each reef subpopulation
    area_tots <- rep(NA, s_reef)
    for(ss in 1:s_reef){

      if(ss == 1){
        area_tots[ss] <- sum(reef_pops[[ss]][[1]][ ,i]*A_mids)
      } else{

        area_tots_ss <- rep(NA, source_reef)

        for(rr in 1:source_reef){
          area_tots_ss[rr] <- sum(reef_pops[[ss]][[rr]][ ,i]*A_mids)
        }

        area_tots[ss] <- sum(area_tots_ss)
      }

    }

    # now calculate the fractions of new recruits that can get outplanted
    prop_fits <- rep(NA, s_reef)

    for(pp in 1:s_reef){

      tot_area_pp <- rest_pars$reef_areas[pp] # total area devoted to the pp^th reef treatment
      occupied_area_pp <- area_tots[pp] # total area currently occupied

      if(occupied_area_pp >= tot_area_pp){ # if the reef subpopulation is full
        prop_fits[pp] <- 0 # no new recruits can be outplanted
      } else{ # else if there's still space
        prop_fits[pp] <- 1 # outplant the recruits
      }

      # open_area_pp <- tot_area_pp - occupied_area_pp # area that is available for new recruits
      #
      # new_area_pp <- new_reef_tots[pp]*A_mids[1] # area that the new recruit outplants will need
      #
      # if(open_area_pp <= 0){ # if there's no space left
      #   prop_fits[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      # } else if(new_area_pp < open_area_pp){ # if all of them fit
      #   prop_fits[pp] <- 1 # all the new recruits can be outplanted
      # } else{ # if only some will fit, calculate what proportion will fit
      #   prop_fits[pp] <- 1-((new_area_pp - open_area_pp)/new_area_pp)
      # }

      }

    # update outplant matrix (remember row = lab treatment where recruits originated, column = reef treatment where recruits are outplanted)
    #reef_outplants <- reef_outplants%*%matrix(prop_fits, nrow = length(reef_treatments), ncol = 1)
    for(ss in 1:s_lab){
      reef_outplants[ss,] <- reef_outplants[ss,]*prop_fits # Note: could update this to give priority to certain lab treatments?
      reef_outplants1[ss,] <- reef_outplants1[ss,]*prop_fits
    }

    # add the outplants to the reef subpopulations
    for(ss in 1:s_reef){

      if(reef_treatments[ss] != "none"){ # if this isn't a reference site (where zero outplants are added)

        for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)

          # add the recruits from the previous year
          reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + reef_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
        
          # store the numbers being outplanted
          reef_out[[ss]][[rr]][i] <- reef_outplants[rr-1,ss] + reef_outplants1[rr-1,ss]
        
        }

      }

      # if "none" treatment also got recruits:
      # for(rr in 1:(source_reef-1)){ # for each lab source (rr = 1 is for external recruits)
      #     reef_pops[[ss]][[rr]][1 ,i] <- reef_pops[[ss]][[rr]][1 ,i] + reef_outplants[ss,rr]


    }


    # repeat for orchard outplants
    orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_orchard) # this year's
    orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_orchard) # last year's

    for(ss in 1:s_lab){

      orchard_outplants[ss, ] <- out_settlers[ss]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      # 1-reef_prop[ss] = proportion lab recruits from ss lab treatment going to orchard
      # orchard_out_props[ss,] = proportion of the orchard outplants from lab treatment ss going to each orchard treatment

      if(substr(lab_treatments[ss], start = 1, stop = 1)=="1"){ # if recruits in ssth treatment were retained a year
        orchard_outplants1[ss, ] <- lab_pops[[ss]][i-1]*(1-rest_pars$reef_prop[ss])*rest_pars$orchard_out_props[ss,]
      }

    }

    # apply space constraints
    # calculate total number of recruits (from all lab treatments) going to each orchard treatment
    new_orchard_tots <- apply(orchard_outplants, 2, sum)

    # calculate total number of corals currently in each orchard subpopulation
    ind_tots <- rep(NA, s_orchard)
    for(ss in 1:s_orchard){

     ind_tots_ss <- rep(NA, source_orchard)

      for(rr in 1:source_orchard){

        ind_tots_ss[rr] <- sum(orchard_pops[[ss]][[rr]][ ,i])
      }

     ind_tots[ss] <- sum(ind_tots_ss)

    }


    # now calculate the fractions of new recruits that will fit in each orchard treatment
    prop_fits2 <- rep(NA, s_orchard)

    for(pp in 1:s_orchard){

      tot_ind_pp <- rest_pars$orchard_size[pp] # total number of individuals that fit in pp^th orchard treatment
      occupied_ind_pp <- ind_tots[pp] # total individuals currently in this orchard subpop

      if(occupied_ind_pp >= tot_ind_pp){ # if the orchard is full
        prop_fits2[pp] <- 0 # no new recruits can be added
      } else{ # else if there's still space
        prop_fits2[pp] <- 1 # add the new recruits
      }

      open_ind_pp <- tot_ind_pp - occupied_ind_pp # number of new recruits that could fit in the orchard subpop

      new_ind_pp <- new_orchard_tots[pp] # total number of new recruits to put in orchard

      if(open_ind_pp <= 0){ # if there's no space left
        prop_fits2[pp] <- 0 # proportion of new recruits that can be outplanted is 0
      } else if(new_ind_pp < open_ind_pp){ # if all of them fit
        prop_fits2[pp] <- 1 # all the new recruits can be outplanted
      } else{ # if only some will fit, calculate what proportion will fit
        prop_fits2[pp] <- 1-((new_ind_pp - open_ind_pp)/new_ind_pp)
      }

    }

    # update outplant matrix (remember row = lab treatment where recruits originated, column = orchard treatment where recruits are outplanted)
   # orchard_outplants <- orchard_outplants%*%matrix(prop_fits2, nrow = length(orchard_treatments), ncol = 1)

    for(ss in 1:s_lab){ # for each lab treatment
      orchard_outplants[ss,] <- orchard_outplants[ss,]*prop_fits2
      orchard_outplants1[ss,] <- orchard_outplants1[ss,]*prop_fits2
    }
    
    # add the outplants to the orchard subpopulations
    for(ss in 1:s_orchard){
      
      for(rr in 1:source_orchard){ # for each lab source
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants[rr,ss]*lab_pars$size_props[rr,]
        
        orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] + orchard_outplants1[rr,ss]*lab_pars$size_props[rr,]
        
        # store the numbers being outplanted
        orchard_out[[ss]][[rr]][i] <- orchard_outplants[rr,ss] + orchard_outplants1[rr,ss]
      }
      
    }
    
    # also make a holding matrix for the recruits that didn't fit in the orchard and go to the reef instead
    # want to distribute these evenly across all intervention reefs 
    
    # if there is at least one intervention reef
    if(length(which(reef_treatments!="none")) > 0){
      
    extra_orchard_outplants <- matrix(0, nrow = s_lab, ncol = s_reef) # this year's
    extra_orchard_outplants1 <- matrix(0, nrow = s_lab, ncol = s_reef) # last year's
    
    for(ss in 1:s_lab){ # for each lab treatment
      
      extra_orchard_outplants[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants[ss,]*(1-prop_fits2))/(length(which(reef_treatments!="none"))), length(which(reef_treatments!="none"))) # this year's
      extra_orchard_outplants1[ss,which(reef_treatments!="none")] <- rep(sum(orchard_outplants1[ss,]*(1-prop_fits2))/length(which(reef_treatments!="none")), length(which(reef_treatments!="none"))) # last year's
      
    }

    
    # add the extras to the reef subpopulations (if there's room on the reef)
      for(ss in 1:s_reef){
        if(prop_fits[ss] !=0){
        
        if(reef_treatments[ss] != "none"){ # if this isn't a reference site (where zero outplants are added)
          
          for(rr in 2:source_reef){ # for each lab source (rr = 1 is for external recruits)
            reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants[rr-1,ss]*lab_pars$size_props[rr-1,] # # need rr-1 here because the reef_outplants matrix only includes the lab treatments as sources (first source is external recruitment)
            
            # add the recruits from the previous year
            reef_pops[[ss]][[rr]][ ,i] <- reef_pops[[ss]][[rr]][ ,i] + extra_orchard_outplants1[rr-1,ss]*lab_pars$size_props[rr-1,] # size_props1 specifies the fractions of last years lab recruits that are now in each size class
            
            # update the numbers being outplanted
            reef_out[[ss]][[rr]][i] <- reef_out[[ss]][[rr]][i] + extra_orchard_outplants[rr-1,ss] + extra_orchard_outplants1[rr-1,ss]
          }
        }
      }
    } # end of iteration over reef subpopulations

  } # end of if(length(which(reef_treatments!="none")) > 0){

    # now add any colony transplants from the orchard to the reef

    if(rest_pars$transplant[i]==1){ # if colonies are moved from orchard to reef this year

        # get the corals that will be transplanted from each size class
        #colony_mats <- list() # holding list for matrices with number of transplant colonies

        for(ss in 1:s_orchard){ # for each orchard subpopulation

          #colony_mat_ss <- list()

          for(rr in 1:source_orchard){ # for each lab source

            trans_colonies <- rest_pars$trans_mats[[ss]][[rr]][i,]

            # make sure these don't exceed the numbers in the population
            for(nn in 1:n){ # for each size class
              # if number to transplant is greater than number available at this timepoint, then only transplant the number of colonies available
              trans_colonies[nn] <- ifelse(trans_colonies[nn] > orchard_pops[[ss]][[rr]][nn ,i], orchard_pops[[ss]][[rr]][nn ,i], trans_colonies[nn])
            }

            # add the colonies to the correct reef population
            ss.reef <- rest_pars$trans_reef[[ss]][[rr]][i,1] # [i,1] = reef area receiving the corals from the ith transplant from the ss/rr^th orchard population
            rr.reef <- rest_pars$trans_reef[[ss]][[rr]][i,2] # [i, 2] = reef source subpopulation receiving the corals from the ith transplant from the ss/rr^th orchard population

            if(prop_fits[ss.reef] !=0){ # if there's room on this reef
            reef_pops[[ss.reef]][[rr.reef]][ ,i] <-  reef_pops[[ss.reef]][[rr.reef]][ ,i] + trans_colonies
            # and substract these from the orchard
            orchard_pops[[ss]][[rr]][ ,i] <- orchard_pops[[ss]][[rr]][ ,i] - trans_colonies
            }

          } # end of iteration over all source subpopulations in ss^th orchard

        } # end of iteration over all orchards

    } # end of if statement for transplanting colonies

  } # end of iteration over each year
  
```



```{r}
# checking subsetting characters: want to make the one-year recruits a separate lab treatment, but can overlap with other treatments so want the names to be "0_tile1" for immediate outplanting and "1_tile1" for year-old outplanting

string_test <- "1_tile1"
substr(string_test, start = 1, stop = 1)


# try a vector of strings
string_test <- c("1_tile1", "0_tile1", "1_tile2")
substr(string_test, start = 1, stop = 1)

length(which(substr(string_test, start = 1, stop = 1)=="1"))

```


connecting orchards and reefs

-- seems like you might not want to do this every year, so make this a vector where 0 means no exchange, "1" means from orchard to reef, and "2" means from reef to orchard
-- and then a matrix specifying the number you want to move from each size class? (and actual number moved would be min of that and actual number in that size class)



```{r}

transplant <- rep(0, years)
transplant[10] <- 1

trans_mat <- matrix(NA, nrow = years, ncol = n)
trans_mat[10,] <- c(0, 0, 0, 3, 0)

harvest_mat <- matrix(NA, nrow = years, ncol = n)

# trans_mat for each reef subpop, all together as a list, then harvest_mat for each orchard also all together in a list

# but also need to think about which treatment is being moved where...
# maybe just make another matrix (or list?) that specifies which orchard treatment(s) to move from and to which reef treatment(s), e.g., I want to take 5 corals from orchard 1 and put them in reef 2

# for each orchard in set of orchards to harvest, get the specified number (assume same number for all), put together into total number of colonies, then put specified numbers in each on each receiving reef. SO need to specify the number that go to each reef -- i.e., there will be trans_mats for each reef, and will need separate matrices for each orchard

```


ACTUALLY should the transplanted corals be there own subpopulation on the reef? That gets complicated...but maybe it's best to do it that way? OR just be sure to keep track of the lab origin (i.e., orchard corals from lab treatment x get put into the reef subpopulation receiving corals from lab treatment x)







